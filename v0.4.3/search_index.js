var documenterSearchIndex = {"docs":
[{"location":"basis/#Bases","page":"Bases","title":"Bases","text":"","category":"section"},{"location":"basis/#Basic-functionality","page":"Bases","title":"Basic functionality","text":"","category":"section"},{"location":"basis/#LinearCombinations.AbstractBasis","page":"Bases","title":"LinearCombinations.AbstractBasis","text":"AbstractBasis{T,N} <: AbstractArray{T,N}\n\nThe supertype of all types representing bases whose elements are of type T. Bases are needed for linear combinations of type DenseLinear.\n\nAll subtypes of AbstractBasis must implement the abstract arrays interface. For a given basis b, b[i] is the i-th basis element. Mapping from basis elements to indices is one via the toindex function. The parameter N == ndims(b) specifies how many indices are used to index elements of a basis b.\n\nSee also Basis, TensorBasis, toindex, Base.ndims.\n\n\n\n\n\n","category":"type"},{"location":"basis/#LinearCombinations.Basis","page":"Bases","title":"LinearCombinations.Basis","text":"Basis{T,N} <: AbstractBasis{T,N}\n\nBasis(iter)\n\nConstruct a Basis whose elements are the elements of the AbstractArray or iterator iter. Internally, basis elements are stored in the given AbstractArray or otherwise in the Array obtained from collect(iter).\n\nSee also AbstractBasis, TensorBasis.\n\nExamples\n\njulia> b = Basis(['a', 'b', 'x', 'y', 'z'])\nBasis(['a', 'b', 'x', 'y', 'z'])\n\njulia> length(b)\n5\n\njulia> i = toindex(b, 'x')\nCartesianIndex(3,)\n\njulia> b[i], b[3]\n('x', 'x')\n\njulia> length(Basis(Char[]))\n0\n\n\n\n\n\n","category":"type"},{"location":"basis/#LinearCombinations.TensorBasis","page":"Bases","title":"LinearCombinations.TensorBasis","text":"TensorBasis{T,N} <: AbstractBasis{T,N}\n\nTensorBasis(bases...)\n\nConstruct a TensorBasis out of the given bases. The elements of the TensorBasis are of type Tensor, where the i-th tensor component is from the i-th basis.\n\nSee also AbstractBasis, Basis.\n\nExamples\n\njulia> b1, b2 = Basis('a':'c'), Basis([\"x\", \"y\", \"z\"])\n(Basis('a':1:'c'), Basis([\"x\", \"y\", \"z\"]))\n\njulia> b3 = TensorBasis(b1, b2)\nTensorBasis(Basis('a':1:'c'), Basis([\"x\", \"y\", \"z\"]))\n\njulia> length(b3)\n9\n\njulia> toindex(b3, Tensor('b', \"z\"))\nCartesianIndex(2, 3)\n\njulia> b4 = TensorBasis(b3, b1)\nTensorBasis(TensorBasis(Basis('a':1:'c'), Basis([\"x\", \"y\", \"z\"])), Basis('a':1:'c'))\n\njulia> ndims(b4)\n3\n\njulia> x = first(b4)\n('a'⊗\"x\")⊗'a'\n\njulia> toindex(b4, x)\nCartesianIndex(1, 1, 1)\n\njulia> b0 = TensorBasis(); length(b0), Tensor() in b0\n(1, true)\n\n\n\n\n\n","category":"type"},{"location":"basis/#Base.getindex-Union{Tuple{N}, Tuple{T}, Tuple{AbstractBasis{T, N}, Vararg{Int64, N}}} where {T, N}","page":"Bases","title":"Base.getindex","text":"getindex(b::AbstractBasis{T,N}, ii::Vararg{Int,N}) -> T\n\nb[ii...] -> T\n\nReturn the basis element indexed by the indices ii.\n\nSee also AbstractBasis, toindex, Base.CartesianIndex.\n\n\n\n\n\n","category":"method"},{"location":"basis/#LinearCombinations.toindex","page":"Bases","title":"LinearCombinations.toindex","text":"toindex(b::AbstractBasis{T,N}, x) where {T,N} -> CartesianIndex{N}\n\nReturn the Cartesian index of the element x in the basis b.\n\nSee also AbstractBasis, Base.CartesianIndex.\n\n\n\n\n\n","category":"function"},{"location":"basis/#AbstractBasis-interface","page":"Bases","title":"AbstractBasis interface","text":"","category":"section"},{"location":"basis/","page":"Bases","title":"Bases","text":"A new subtype of AbstractBasis must provide a method for toindex and satisfy the abstract arrays interface for read-only arrays. The latter means that size and getindex must be supported.","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"As an example, here is subtype of AbstractBasis that turns ranges into bases. The advantage over Basis is that no dictionary lookup is needed for toindex.","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"import Base: show, size, getindex\nimport LinearCombinations: toindex\n\nstruct RangeBasis{T,R<:AbstractRange{T}} <: AbstractBasis{T,1}\n    range::R\nend\n\nshow(io::IO, b::RangeBasis) = print(io, \"RangeBasis(\", b.range, ')')\n\nsize(b::RangeBasis) = size(b.range)\n\ngetindex(b::RangeBasis, i::Int) = b.range[i]\n\nfunction toindex(b::RangeBasis, x)\n    d, r = divrem(x-first(b.range), step(b.range))\n    d += 1\n    if r == 0 && firstindex(b.range) <= d <= lastindex(b.range)\n        CartesianIndex(d)\n    else\n        error(\"$x is not an element of the basis $b\")\n    end\nend","category":"page"},{"location":"linear/#Linear-combinations","page":"Linear combinations","title":"Linear combinations","text":"","category":"section"},{"location":"linear/#Types","page":"Linear combinations","title":"Types","text":"","category":"section"},{"location":"linear/#LinearCombinations.AbstractLinear","page":"Linear combinations","title":"LinearCombinations.AbstractLinear","text":"L(xc::Pair...; is_filtered = false; kw...) where L <: AbstractLinear\nL(itr; is_filtered = false; kw...) where L <: AbstractLinear\n\nAbstractLinear{T,R} is the supertype of all linear combinations with term type T and coefficient type R.\n\nA constructor for a subtype L <: AbstractLinear constructs a linear combination of type L out of the given term-coefficient pairs of the form x => c where x is the term and c the coefficient, or out of the pairs provided by the iterator itr. It must be possible to convert all terms and coefficients to the chosen term type and coefficient type, respectively.\n\nNeither the term type nor the coefficient type need to be concrete. (Of course, concrete types lead to better performance.) If the coefficient type and possibly also the term type are not specified, the constructor tries to determine them using promote_type (for coefficients) and promote_typejoin (for terms).\n\nIf two or more term-coefficient pairs are given with the same term, then the corresponding coefficients are added up. This is different from dictionaries, where any key-value pair overrides previous pairs with the same key. However, the implemented behavior is more useful for linear combinations.\n\nFor specialized applications, terms and coefficients can be processed with linear_filter and termcoeff before being stored in a linear combination. The keyword argument is_filtered controls whether linear_filter is called for each term.\n\nBy default, linear combinations are displayed in a human-readable form with a limited number of terms. Dedicated show methods display all terms of a linear combination or return an expression that Julia can parse as input. See the examples below.\n\nSee also Linear, DenseLinear, Linear1, linear_filter, LinearCombinations.termcoeff, Base.show\n\nExamples\n\njulia> Linear('x' => 1, 'y' => 2)\nLinear{Char, Int64} with 2 terms:\n'x'+2*'y'\n\njulia> Linear(x => c for (c, x) in enumerate('u':'z'))\nLinear{Char, Int64} with 6 terms:\n3*'w'+2*'v'+4*'x'+'u'+5*'y'+6*'z'\n\njulia> Linear{Char,Int}('x' => 1, 'y' => Int8(0), 'x' => 3.0)\nLinear{Char, Int64} with 1 term:\n4*'x'\n\njulia> a = Linear('x' => BigInt(1), \"yz\" => 2.0)\nLinear{Any, BigFloat} with 2 terms:\n'x'+2.0*\"yz\"\n\nIterating over a linear combination yields all non-zero term-coefficient pairs. Hence a linear combination can itself be used an argument to an AbstractLinear constructor.\n\njulia> Linear{Union{Char,String}}(a)   # same a as before\nLinear{Union{Char, String}, BigFloat} with 2 terms:\n'x'+2.0*\"yz\"\n\nVarious forms to display a linear combination.\n\njulia> a = Linear(x => 1 for x in 'a':'z')\nLinear{Char, Int64} with 26 terms:\n'n'+'f'+'w'+'d'+'e'+'o'+'h'+'j'+'i'+'k'+'r'+'s'+'t'+'q'+'y'+'a'+'c'+'p'+'m'+'z'±⋯\n\njulia> show(stdout, MIME\"text/plain\"(), a)  # all terms\nLinear{Char, Int64} with 26 terms:\n'n'+'f'+'w'+'d'+'e'+'o'+'h'+'j'+'i'+'k'+'r'+'s'+'t'+'q'+'y'+'a'+'c'+'p'+'m'+'z'+'g'+'v'+'l'+'u'+'x'+'b'\n\njulia> b = Linear('a' => 1, 'y' => 2)\nLinear{Char, Int64} with 2 terms:\n'a'+2*'y'\n\njulia> show(b)  # can be parsed as input\nLinear{Char, Int64}('a' => 1, 'y' => 2)\n\n\n\n\n\n","category":"type"},{"location":"linear/#LinearCombinations.Linear","page":"Linear combinations","title":"LinearCombinations.Linear","text":"Linear{T,R} <: AbstractLinear{T,R}\n\nLinear{T,R}(itr)\n\nConstruct a linear combination of type Linear with term type T and coefficient type R out of the term-coefficient pairs provided by the iterator itr.\n\nLinear combinations of this type are sparse in the sense that terms and (non-zero) coefficients are internally stored in a dictionary.\n\nOther ways to use this constructor are discussed under AbstractLinear.\n\nSee also AbstractLinear, DenseLinear, Linear1.\n\n\n\n\n\n","category":"type"},{"location":"linear/#LinearCombinations.DenseLinear","page":"Linear combinations","title":"LinearCombinations.DenseLinear","text":"DenseLinear{T,R} <: AbstractLinear{T,R}\n\nDenseLinear{T,R}(itr; basis::Basis)\n\nConstruct a linear combination of type DenseLinear with term type T and coefficient type R out of the term-coefficient pairs provided by the iterator itr.\n\nLinear combinations of this type are internally stored as a Vector (or, more generally, an AbstractArray). The mandatory keyword argument basis is used to translate between terms and entries of the Vector (or Array). Operations involving two DenseLinear elements are much faster when the two bases are identical (in the sense of ===).\n\nOther ways to use this constructor are discussed under AbstractLinear.\n\nSee also Basis, AbstractLinear, Linear, Linear1, basis, coordinates.\n\nExamples\n\njulia> azbasis = Basis('a':'z')\nBasis('a':1:'z')\n\njulia> a = DenseLinear('x' => 1, 'y' => 2; basis = azbasis)\nDenseLinear{Char, Int64} with 2 terms:\n'x'+2*'y'\n\njulia> a + 'z'\nDenseLinear{Char, Int64} with 3 terms:\n'x'+2*'y'+'z'\n\njulia> a + 'X'\nERROR: KeyError: key 'X' not found\n[...]\n\njulia> b = DenseLinear('x' => -1, 'z' => 3; basis = azbasis)\nDenseLinear{Char, Int64} with 2 terms:\n-'x'+3*'z'\n\njulia> a + b\nLinear{Char, Int64} with 2 terms:\n2*'y'+3*'z'\n\njulia> c = DenseLinear('a' => 5; basis = Basis('a':'c'))\nDenseLinear{Char, Int64} with 1 term:\n5*'a'\n\njulia> add!(a, c)\nDenseLinear{Char, Int64} with 3 terms:\n5*'a'+'x'+2*'y'\n\njulia> add!(c, a)\nERROR: KeyError: key 'x' not found\n\n\n\n\n\n","category":"type"},{"location":"linear/#LinearCombinations.Linear1","page":"Linear combinations","title":"LinearCombinations.Linear1","text":"Linear1{T,R} <: AbstractLinear{T,R}\n\nLinear1{T,R}(itr)\n\nConstruct a linear combination of type Linear1 with term type T and coefficient type R out of the term-coefficient pairs provided by the iterator itr.\n\nLinear combinations of this type can hold at most one non-zero term-coefficient pair at any time. There are often situations where this is sufficient, and in these cases Linear1 is much more efficient than Linear or DenseLinear.\n\nOther ways to use this constructor are discussed under AbstractLinear.\n\nSee also AbstractLinear, Linear, DenseLinear.\n\nExamples\n\njulia> a = Linear1('x' => 1)\nLinear1{Char, Int64} with 1 term:\n'x'\n\njulia> add!(a, 'x')\nLinear1{Char, Int64} with 1 term:\n2*'x'\n\njulia> addmul!(a, 'x', -2)\nLinear1{Char, Int64} with 0 terms:\n0\n\njulia> a + 'y'   # works because a is zero\nLinear1{Char, Int64} with 1 term:\n'y'\n\njulia> a + 'y' + 'z'\nERROR: Linear1 cannot store linear combinations of two or more elements\n[...]\n\njulia> a = Linear1('x' => 1); b = Linear1('y' => 2); a+b\nLinear{Char, Int64} with 2 terms:\n'x'+2*'y'\n\njulia> typeof(ans)\nLinear{Char, Int64}\n\n\n\n\n\n","category":"type"},{"location":"linear/#Basic-methods","page":"Linear combinations","title":"Basic methods","text":"","category":"section"},{"location":"linear/#LinearCombinations.termtype","page":"Linear combinations","title":"LinearCombinations.termtype","text":"termtype(::Type{L}) where L <: AbstractLinear{T,R} = T\ntermtype(a::L) where L <: AbstractLinear{T,R} = T\n\nReturn the type of the terms (basis elements) in a linear combination.\n\nSee also coefftype.\n\n\n\n\n\n","category":"function"},{"location":"linear/#LinearCombinations.coefftype","page":"Linear combinations","title":"LinearCombinations.coefftype","text":"coefftype(::Type{L}) where L <: AbstractLinear{T,R} = R\ncoefftype(a::L) where L <: AbstractLinear{T,R} = R\n\nReturn the type of the coefficients in a linear combination.\n\nSee also termtype.\n\n\n\n\n\n","category":"function"},{"location":"linear/#Base.in-Tuple{Any, AbstractLinear}","page":"Linear combinations","title":"Base.in","text":"x in a::AbstractLinear -> Bool\n\nReturn true if the term x appears in the linear combination a with a non-zero coefficient, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"linear/#Base.length-Tuple{AbstractLinear}","page":"Linear combinations","title":"Base.length","text":"length(a::AbstractLinear) -> Int\n\nReturn the number of non-zero terms in a.\n\n\n\n\n\n","category":"method"},{"location":"linear/#Base.iterate-Tuple{AbstractLinear}","page":"Linear combinations","title":"Base.iterate","text":"iterate(a::AbstractLinear [, state])\n\nIterating over a linear combination yields all non-zero term-coefficient pairs.\n\nExamples\n\njulia> a = Linear('x' => 1, 'y' => 2, 'z' => 0)\nLinear{Char, Int64} with 2 terms:\n'x'+2*'y'\n\njulia> collect(a)\n2-element Vector{Pair{Char, Int64}}:\n 'x' => 1\n 'y' => 2\n\njulia> Linear(x => c^2 for (x, c) in a)\nLinear{Char, Int64} with 2 terms:\n'x'+4*'y'\n\n\n\n\n\n","category":"method"},{"location":"linear/#LinearCombinations.coeffs","page":"Linear combinations","title":"LinearCombinations.coeffs","text":"coeffs(a::AbstractLinear)\n\nReturn an iterator over the non-zero coefficients appearing in a.\n\n\n\n\n\n","category":"function"},{"location":"linear/#LinearCombinations.terms","page":"Linear combinations","title":"LinearCombinations.terms","text":"terms(a::AbstractLinear)\n\nReturn an iterator over the terms appearing in a (with a non-zero coefficient).\n\n\n\n\n\n","category":"function"},{"location":"linear/#Base.zero","page":"Linear combinations","title":"Base.zero","text":"zero(::Type{L}; kw...) where L <: AbstractLinear -> L\nzero(a::L) where L <: AbstractLinear -> L\n\nReturn a zero linear combination of type L. If zero is called with a type L <: AbstractLinear as argument, then keyword arguments may be accepted or required.\n\nSee also zero!.\n\n\n\n\n\n","category":"function"},{"location":"linear/#LinearCombinations.zero!","page":"Linear combinations","title":"LinearCombinations.zero!","text":"zero!(a::AbstractLinear) -> a\n\nSet a equal to the zero linear combination and return a.\n\nSee also zero.\n\n\n\n\n\n","category":"function"},{"location":"linear/#Base.copy","page":"Linear combinations","title":"Base.copy","text":"copy(a::L) where L <: AbstractLinear -> L\n\nReturn a copy of a.\n\n\n\n\n\n","category":"function"},{"location":"linear/#Base.copyto!","page":"Linear combinations","title":"Base.copyto!","text":"copyto!(a::AbstractLinear, b::AbstractLinear, c = 1) -> a\ncopyto!(a::AbstractLinear, x, c = 1) -> a\n\nSet a equal to the c-fold multiple of the linear combination b or of the term x. If the scalar c is omitted, it is taken to be 1.\n\n\n\n\n\n","category":"function"},{"location":"linear/#Base.sizehint!","page":"Linear combinations","title":"Base.sizehint!","text":"sizehint!(a::AbstractLinear, n::Integer) -> a\n\nTry to make room for in total n non-zero term-coefficient pairs in the linear combination a.\n\nThis can speed up computations. At present, sizehint! has an effect for elements of type Linear (which internally use a dictionary) and is ignored for all other subtypes of AbstractLinear.\n\nSee also Linear, LinearCombinations.has_sizehint, Base.sizehint!(d::AbstractDict).\n\n\n\n\n\n","category":"function"},{"location":"linear/#Base.convert","page":"Linear combinations","title":"Base.convert","text":"convert(::Type{L}, a::AbstractLinear; kw...) where L <: AbstractLinear -> L\nconvert(::Type{L}, x; kw...) where L <: AbstractLinear -> L\n\nConvert the linear combination a or the term x to a linear combination of type L. Keyword arguments are passed to the constructor for L.\n\nExamples\n\njulia> a = Linear{AbstractChar,Int}('x' => 2)\nLinear{AbstractChar, Int64} with 1 term:\n2*'x'\n\njulia> b = convert(Linear{Char,Float64}, a)\nLinear{Char, Float64} with 1 term:\n2.0*'x'\n\njulia> convert(Linear{Char,Int}, 'x') == Linear('x' => 1)\ntrue\n\njulia> convert(DenseLinear, a; basis = Basis('a':'z'))\nDenseLinear{AbstractChar, Int64} with 1 term:\n2*'x'\n\n\n\n\n\n","category":"function"},{"location":"linear/#Additional-functions-for-DenseLinear","page":"Linear combinations","title":"Additional functions for DenseLinear","text":"","category":"section"},{"location":"linear/#LinearCombinations.basis","page":"Linear combinations","title":"LinearCombinations.basis","text":"basis(a::DenseLinear) -> Basis\n\nReturn the basis specified when a was defined.\n\nSee also coordinates.\n\n\n\n\n\n","category":"function"},{"location":"linear/#LinearCombinations.coordinates","page":"Linear combinations","title":"LinearCombinations.coordinates","text":"coordinates(a::DenseLinear{T,R}) -> AbstractArray{R}\n\nReturn the coordinates of a with respect to the basis used for it. The coordinate array (usually a vector) has the same axes as the basis. Modifying this array will also modify a.\n\nSee also basis.\n\nExample\n\njulia> b = Basis('x':'z')\nBasis('x':1:'z')\n\njulia> a = DenseLinear('x' => 1, 'z' => 2; basis = b)\nDenseLinear{Char, Int64} with 2 terms:\n'x'+2*'z'\n\njulia> v = coordinates(a)\n3-element Vector{Int64}:\n 1\n 0\n 2\n\njulia> a == Linear(x => c for (x, c) in zip(basis(a), v))\ntrue\n\njulia> v[2] = -1; a\nDenseLinear{Char, Int64} with 3 terms:\n'x'-'y'+2*'z'\n\n\n\n\n\n","category":"function"},{"location":"linear/#Arithmetic","page":"Linear combinations","title":"Arithmetic","text":"","category":"section"},{"location":"linear/#LinearCombinations.add!","page":"Linear combinations","title":"LinearCombinations.add!","text":"add!(a::AbstractLinear, b::AbstractLinear) -> a\nadd!(a::AbstractLinear, x) -> a\n\nAdd the linear combination b or the term x to a. This function modifies a.\n\nSee also addmul!, sub!.\n\n\n\n\n\n","category":"function"},{"location":"linear/#LinearCombinations.sub!","page":"Linear combinations","title":"LinearCombinations.sub!","text":"sub!(a::AbstractLinear, b::AbstractLinear) -> a\nsub!(a::AbstractLinear, x) -> a\n\nSubtract the linear combination b or the term x from a. This function modifies a.\n\nSee also addmul!, add!.\n\n\n\n\n\n","category":"function"},{"location":"linear/#LinearCombinations.mul!","page":"Linear combinations","title":"LinearCombinations.mul!","text":"mul!(a::AbstractLinear, c) -> a\n\nMultiply a by the scalar c. This functions modifies a.\n\nSee also addmul!.\n\n\n\n\n\n","category":"function"},{"location":"linear/#LinearCombinations.addmul!","page":"Linear combinations","title":"LinearCombinations.addmul!","text":"addmul!(a::AbstractLinear, b::AbstractLinear, c) -> a\naddmul!(a::AbstractLinear, x, c) -> a\n\nAdd the c-fold multiple of the linear combination b or of the term x to a, where c is a scalar. This function modifies a.\n\nSee also addmul, add!, sub!, mul!.\n\n\n\n\n\n","category":"function"},{"location":"linear/#LinearCombinations.addmul","page":"Linear combinations","title":"LinearCombinations.addmul","text":"addmul(a::AbstractLinear, b::AbstractLinear, c)\naddmul(a::AbstractLinear, x, c)\n\nAdd the c-fold multiple of the linear combination b or of the term x to a, where c is a scalar.\n\nSee also addmul!.\n\n\n\n\n\n","category":"function"},{"location":"linear/#LinearCombinations.deg-Tuple{AbstractLinear}","page":"Linear combinations","title":"LinearCombinations.deg","text":"deg(a::AbstractLinear)\n\nReturn deg(x) where x is the first term appearing in a (as determined by first(a)).\n\nThe linear combination a must not be zero. If a is homogeneous, then deg(a) is the common degree of all terms in it.\n\n\n\n\n\n","category":"method"},{"location":"linear/#Calling-linear-combinations","page":"Linear combinations","title":"Calling linear combinations","text":"","category":"section"},{"location":"linear/","page":"Linear combinations","title":"Linear combinations","text":"Calling objects is extended linearly. Here is an example:","category":"page"},{"location":"linear/","page":"Linear combinations","title":"Linear combinations","text":"julia> struct P{T} y::T end\n\njulia> Base.hash(p::P, h::UInt) = hash(p.y, hash(P, h));  # `Linear` uses hashing\n\njulia> @linear p::P; (p::P)(x) = x * p.y\n\njulia> p, q = P('p'), P('q')\n(P{Char}('p'), P{Char}('q'))\n\njulia> p('x')\n\"xp\"\n\njulia> a = Linear('x' => 1, 'y' => 2)\nLinear{Char, Int64} with 2 terms:\n'x'+2*'y'\n\njulia> p(a)\nLinear{String, Int64} with 2 terms:\n2*\"yp\"+\"xp\"\n\njulia> u = Linear(p => -1, q => 3)\nLinear{P{Char}, Int64} with 2 terms:\n-P{Char}('p')+3*P{Char}('q')\n\njulia> u('x')\nLinear{String, Int64} with 2 terms:\n3*\"xq\"-\"xp\"\n\njulia> u(a)\nLinear{String, Int64} with 4 terms:\n3*\"xq\"-2*\"yp\"+6*\"yq\"-\"xp\"","category":"page"},{"location":"linear/#Broadcasting","page":"Linear combinations","title":"Broadcasting","text":"","category":"section"},{"location":"linear/","page":"Linear combinations","title":"Linear combinations","text":"Broadcasting is supported for AbstractLinear types. Broadcasted versions of +, -, *, = are converted to addmul!, mul! and copyto! as much as possible to avoid (or at least minimize) allocations. For example, for linear combinations a, b, c and d, the statement","category":"page"},{"location":"linear/","page":"Linear combinations","title":"Linear combinations","text":"   a .= b .+ 2 .* (c .- 3 .* d)","category":"page"},{"location":"linear/","page":"Linear combinations","title":"Linear combinations","text":"is translated to","category":"page"},{"location":"linear/","page":"Linear combinations","title":"Linear combinations","text":"    copyto!(a, b)\n    addmul!(a, c, 2)\n    addmul!(a, d, 2*(-3))","category":"page"},{"location":"linear/","page":"Linear combinations","title":"Linear combinations","text":"and the statement","category":"page"},{"location":"linear/","page":"Linear combinations","title":"Linear combinations","text":"    a .+= b .+ 2 .* (c .- 3 .* d)","category":"page"},{"location":"linear/","page":"Linear combinations","title":"Linear combinations","text":"to","category":"page"},{"location":"linear/","page":"Linear combinations","title":"Linear combinations","text":"    addmul!(a, b)\n    addmul!(a, c, 2)\n    addmul!(a, d, 2*(-3))","category":"page"},{"location":"linear/","page":"Linear combinations","title":"Linear combinations","text":"Broadcasted .* is always interpreted as scalar multiplication, with the scalar as the first argument. The only exception is a statement of the form a .*= c (that is, a .= a .* c) where the scalar is the second argument.","category":"page"},{"location":"linear/","page":"Linear combinations","title":"Linear combinations","text":"By default, only elements of types AbstractLinear and Number participate in broadcasting. To allow other scalar or term types, one has to use the macro @linear_broadcastable.","category":"page"},{"location":"linear/","page":"Linear combinations","title":"Linear combinations","text":"julia> @linear_broadcastable Char\n\njulia> a, b = Linear('x' => 1), Linear('y' => 2)\n(Linear{Char, Int64}('x' => 1), Linear{Char, Int64}('y' => 2))\n\njulia> a .+= b .+ 2 .* 'z'\nLinear{Char, Int64} with 3 terms:\n'x'+2*'y'+2*'z'\n\njulia> a\nLinear{Char, Int64} with 3 terms:\n'x'+2*'y'+2*'z'","category":"page"},{"location":"linear/#LinearCombinations.@linear_broadcastable","page":"Linear combinations","title":"LinearCombinations.@linear_broadcastable","text":"@linear_broadcastable T\n\nAdd the type T to the types that participate in broadcasting for linear combinations. By default, only the types AbstractLinear and Number are available. (A few others happen to work as well, for example AbstractChar.)\n\nSee also LinearCombinations.LinearStyle.\n\n\n\n\n\n","category":"macro"},{"location":"linear/#AbstractLinear-interface","page":"Linear combinations","title":"AbstractLinear interface","text":"","category":"section"},{"location":"linear/#LinearCombinations.getcoeff","page":"Linear combinations","title":"LinearCombinations.getcoeff","text":"LinearCombinations.getcoeff(a::AbstractLinear{T,R}, x) where {T,R} -> R\n\nReturn the coefficient of x in the linear combination a. This is zero(R) if x does not appear in a.\n\nThis function is part of the AbstractLinear interface. When it is called, the term x has already been transformed via termcoeff, and linear_filter(x) is true.\n\nSee also LinearCombinations.setcoeff!, linear_filter, LinearCombinations.termcoeff.\n\n\n\n\n\n","category":"function"},{"location":"linear/#LinearCombinations.setcoeff!","page":"Linear combinations","title":"LinearCombinations.setcoeff!","text":"LinearCombinations.setcoeff!(a::AbstractLinear{T,R}, c, x) where {T,R} -> c\n\nSet the coefficient of x in the linear combination a equal to c and return c.\n\nThis function is part of the AbstractLinear interface. When it is called, both x and c have already been transformed via termcoeff, and linear_filter(x) is true.\n\nSee also LinearCombinations.getcoeff, linear_filter, LinearCombinations.termcoeff.\n\n\n\n\n\n","category":"function"},{"location":"linear/#LinearCombinations.modifycoeff!","page":"Linear combinations","title":"LinearCombinations.modifycoeff!","text":"LinearCombinations.modifycoeff!(op, a::AbstractLinear, x, c) -> a\n\nReplace the coefficient of x in a by op(getcoeff(a, x), c) and return a. Here op is either + or -.\n\nThis function is called after termcoeff and linear_filter.\n\nSee also linear_filter, LinearCombinations.termcoeff, LinearCombinations.modifylinear!.\n\n\n\n\n\n","category":"function"},{"location":"linear/#LinearCombinations.modifylinear!","page":"Linear combinations","title":"LinearCombinations.modifylinear!","text":"LinearCombinations.modifylinear!(op, a::AbstractLinear, b::AbstractLinear, c = missing) -> a\n\nIf op is +, add c*b to a, or just b if c is missing. If op is -, subtract b or c*b from a. Store the new value in a and return it.\n\nSee also LinearCombinations.modifycoeff!.\n\n\n\n\n\n","category":"function"},{"location":"basics/#Basic-functions","page":"Basic functions","title":"Basic functions","text":"","category":"section"},{"location":"basics/#Functions-for-terms","page":"Basic functions","title":"Functions for terms","text":"","category":"section"},{"location":"basics/#LinearCombinations.deg-Tuple{Any}","page":"Basic functions","title":"LinearCombinations.deg","text":"deg(x)\n\nReturn the degree of x. The default value of deg(x) is 0. (More precisely, it is LinearCombinations.Zero(), which behaves like 0.)\n\nSee also deg(::AbstractTensor), LinearCombinations.Zero.\n\n\n\n\n\n","category":"method"},{"location":"basics/#Traits-and-functions-for-rings","page":"Basic functions","title":"Traits and functions for rings","text":"","category":"section"},{"location":"basics/#LinearCombinations.has_char2","page":"Basic functions","title":"LinearCombinations.has_char2","text":"has_char2(::Type{R}) where R -> Bool\n\nReturn true if the ring R is known to have characteristic 2 and false otherwise.\n\nBy default, has_char2 returns false for all arguments. Changing it to true for a ring R avoids (possibly expensive) sign computations.\n\nSee also is_domain.\n\n\n\n\n\n","category":"function"},{"location":"basics/#LinearCombinations.is_domain","page":"Basic functions","title":"LinearCombinations.is_domain","text":"is_domain(::Type{R}) where R -> Bool\n\nReturn true if the ring R is known to be integral domain and false otherwise. An integral domain is a commutative ring without zero divisors.\n\nBy default, is_domain returns true only for subtypes of Real and Complex. If is_domain(R) == true, then sometimes more efficient algorithms can be chosen.\n\nSee also has_char2.\n\n\n\n\n\n","category":"function"},{"location":"basics/#LinearCombinations.signed","page":"Basic functions","title":"LinearCombinations.signed","text":"LinearCombinations.signed(k, x)\n\nReturn a value representing (-1)^k*x. The default definition is\n\nsigned(k, x::R) where R = has_char2(R) || iseven(k) ? x : -x\n\nAdditional methods may be needed to support more exotic coefficient types.\n\n\n\n\n\n","category":"function"},{"location":"tensor/#Tensors","page":"Tensors","title":"Tensors","text":"","category":"section"},{"location":"tensor/#LinearCombinations.AbstractTensor","page":"Tensors","title":"LinearCombinations.AbstractTensor","text":"AbstractTensor{T<:Tuple}\n\nThe supertype of all tensor types. Currently the only subtype is Tensor.\n\nSee Tensor, tensor, Tuple(t::AbstractTensor).\n\n\n\n\n\n","category":"type"},{"location":"tensor/#Constructors","page":"Tensors","title":"Constructors","text":"","category":"section"},{"location":"tensor/#LinearCombinations.Tensor","page":"Tensors","title":"LinearCombinations.Tensor","text":"Tensor{T<:Tuple}\n\nTensor{T}(xs...) where T\nTensor(xs...)\n\nThe type Tensor represents pure tensors.\n\nA general tensor is a linear combination of pure tensors and can conveniently be created using tensor. LinearCombinations takes pure tensors as basis elements.\n\nA Tensor can be created out of a Tuple or out of the individual components. The second form is not available if the tensor has a tuple as its only component.\n\nTensor implements the iteration and indexing interfaces. This makes for example splatting available for tensors, and the i-th component of t::Tensor can be accessed as t[i].\n\nTensors can be nested. Different bracketings lead to different tensors. The functions cat, flatten, swap and regroup are provided to make rearranging tensors more easily.\n\nNote that the type parameter of Tensor is always a Tuple. For instance, the type of a Tensor with two components of types T1 and T2 is Tensor{Tuple{T1,T2}}, not Tensor{T1,T2}.\n\nSee also tensor, cat, flatten, regroup, swap.\n\nExamples\n\njulia> t = Tensor('x', 'y', \"z\")\n'x'⊗'y'⊗\"z\"\n\njulia> typeof(t)\nTensor{Tuple{Char, Char, String}}\n\njulia> Tuple(t)\n('x', 'y', \"z\")\n\njulia> length(t), t[2], t[end]\n(3, 'y', \"z\")\n\njulia> a = Linear('x' => 1, 'y' => 2)\nLinear{Char, Int64} with 2 terms:\n'x'+2*'y'\n\njulia> b = Linear(Tensor('x', 'z') => 1, Tensor('y', 'z') => 2)\nLinear{Tensor{Tuple{Char, Char}}, Int64} with 2 terms:\n2*'y'⊗'z'+'x'⊗'z'\n\njulia> b == tensor(a, 'z')\ntrue\n\njulia> [uppercase(x) for x in t]\n3-element Vector{Any}:\n 'X': ASCII/Unicode U+0058 (category Lu: Letter, uppercase)\n 'Y': ASCII/Unicode U+0059 (category Lu: Letter, uppercase)\n \"Z\"\n\njulia> f((x1, xs...)::Tensor) = x1\nf (generic function with 1 method)\n\njulia> f(t)\n'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)\n\njulia> t == Tensor(Tensor('x', 'y'), \"z\")\nfalse\n\njulia> a = tensor(); a[Tensor()]\n1\n\n\n\n\n\n","category":"type"},{"location":"tensor/#LinearCombinations.tensor","page":"Tensors","title":"LinearCombinations.tensor","text":"tensor(xs...) -> Linear{Tensor}\nx1 ⊗ x2 ⊗ ... -> Linear{Tensor}\n\ntensor is the multilinear extension of Tensor. ⊗ is a synomym for tensor. Note that tensor always returns a linear combination.\n\nSee also Tensor, @multilinear\n\nExamples\n\njulia> a = Linear('x' => 1, 'y' => 2)\nLinear{Char, Int64} with 2 terms:\n'x'+2*'y'\n\njulia> b = Linear(\"w\" => 3, \"z\" => -1)\nLinear{String, Int64} with 2 terms:\n3*\"w\"-\"z\"\n\njulia> tensor(a, \"w\")\nLinear{Tensor{Tuple{Char, String}}, Int64} with 2 terms:\n'x'⊗\"w\"+2*'y'⊗\"w\"\n\njulia> tensor(a, b)\nLinear{Tensor{Tuple{Char, String}}, Int64} with 4 terms:\n3*'x'⊗\"w\"-'x'⊗\"z\"-2*'y'⊗\"z\"+6*'y'⊗\"w\"\n\njulia> tensor('x', b, a; coefftype = Float64)\nLinear{Tensor{Tuple{Char, String, Char}}, Float64} with 4 terms:\n6.0*'x'⊗\"w\"⊗'y'+3.0*'x'⊗\"w\"⊗'x'-2.0*'x'⊗\"z\"⊗'y'-'x'⊗\"z\"⊗'x'\n\njulia> a = tensor(); a[Tensor()]\n1\n\n\n\n\n\n","category":"function"},{"location":"tensor/#Manipulating-tensors","page":"Tensors","title":"Manipulating tensors","text":"","category":"section"},{"location":"tensor/#Core.Tuple-Tuple{AbstractTensor}","page":"Tensors","title":"Core.Tuple","text":"Tuple(t::AbstractTensor{T}) -> T <: Tuple\n\nReturn the tuple of components of t.\n\nAlthough any AbstractTensor has to supports the iteration interface, it is often more efficient to deal with the underlying Tuple of components. For instance, functions like map or reduce map return a Tuple in this case instead of a Vector.\n\nExample\n\njulia> t = Tensor('A','b','c')\n'A'⊗'b'⊗'c'\n\njulia> Tuple(t)\n('A', 'b', 'c')\n\njulia> map(isuppercase, t)\n3-element Vector{Bool}:\n 1\n 0\n 0\n\njulia> map(isuppercase, Tuple(t))\n(true, false, false)\n\n\n\n\n\n","category":"method"},{"location":"tensor/#LinearCombinations.cat","page":"Tensors","title":"LinearCombinations.cat","text":"cat(t::AbstractTensor...) -> Tensor\n\nConcatenate the tensors given as arguments. This function is multilinear.\n\nSee also flatten.\n\nExample\n\njulia> LinearCombinations.cat(Tensor('x'), Tensor('y', Tensor('z', 'w')))\n'x'⊗'y'⊗('z'⊗'w')\n\n\n\n\n\n","category":"function"},{"location":"tensor/#LinearCombinations.flatten","page":"Tensors","title":"LinearCombinations.flatten","text":"flatten(t::AbstractTensor) -> Tensor\nflatten(a::AbstractLinear{<:AbstractTensor}) -> AbstractLinear{Tensor}\n\nRecursively take all tensor components and concatenate the result. This function is linear.\n\nSee also cat.\n\nExample\n\njulia> t = Tensor('x', Tensor('y', Tensor('z', 'w')))\n'x'⊗('y'⊗('z'⊗'w'))\n\njulia> flatten(t)\n'x'⊗'y'⊗'z'⊗'w'\n\n\n\n\n\n","category":"function"},{"location":"tensor/#LinearCombinations.swap","page":"Tensors","title":"LinearCombinations.swap","text":"swap(t::AbstractTensor{Tuple{T1,T2}}) where {T1,T2} -> AbstractLinear{Tensor{Tuple{T2,T1}}}\nswap(a::AbstractLinear{AbstractTensor{Tuple{T1,T2}})}) where {T1,T2}\n    -> AbstractLinear{Tensor{Tuple{T1,T2}})}\n\nThis linear function swaps the components of two-component tensors. If the two components of a tensor t have non-zero degrees, then the usual sign (-1)^(deg(t[1])*deg(t[2])) is introduced. By default, all terms have zero degree.\n\nNote that swap is a special case of regroup:  it is simply defined as regroup(:((1, 2)), :((2, 1))).\n\nSee also Tensor, deg, regroup, LinearCombinations.DefaultCoefftype.\n\nExamples\n\nExamples without degrees\n\njulia> t = Tensor(\"x\", \"z\")\n\"x\"⊗\"z\"\n\njulia> swap(t)\nLinear1{Tensor{Tuple{String, String}}, Int64} with 1 term:\n\"z\"⊗\"x\"\n\njulia> a = Linear(\"x\" => 1, \"yy\" => 1) ⊗ Linear(\"z\" => 1, \"ww\" => 1)\nLinear{Tensor{Tuple{String, String}}, Int64} with 4 terms:\n\"x\"⊗\"ww\"+\"yy\"⊗\"ww\"+\"yy\"⊗\"z\"+\"x\"⊗\"z\"\n\njulia> swap(a)\nLinear{Tensor{Tuple{String, String}}, Int64} with 4 terms:\n\"ww\"⊗\"x\"+\"z\"⊗\"yy\"+\"z\"⊗\"x\"+\"ww\"⊗\"yy\"\n\njulia> swap(a; coeff = 2)\nLinear{Tensor{Tuple{String, String}}, Int64} with 4 terms:\n2*\"ww\"⊗\"x\"+2*\"z\"⊗\"yy\"+2*\"z\"⊗\"x\"+2*\"ww\"⊗\"yy\"\n\nExamples with degrees\n\nFor simplicity, we define the degree of a String to be its length.\n\njulia> LinearCombinations.deg(x::String) = length(x)\n\njulia> swap(t)   # same t as before\nLinear1{Tensor{Tuple{String, String}}, Int64} with 1 term:\n-\"z\"⊗\"x\"\n\njulia> swap(a)   # same a as before\nLinear{Tensor{Tuple{String, String}}, Int64} with 4 terms:\n\"ww\"⊗\"x\"+\"z\"⊗\"yy\"-\"z\"⊗\"x\"+\"ww\"⊗\"yy\"\n\n\n\n\n\n","category":"constant"},{"location":"tensor/#LinearCombinations.Regroup","page":"Tensors","title":"LinearCombinations.Regroup","text":"LinearCombinations.Regroup{A, B}\n\nApplying a Regroup object to a Tensor or a linear combinations of tensors rearranges the components of the tensor. Use regroup to create a Regroup object. It is possible to define additional methods to apply Regroup objects to other arguments besides tensors.\n\nSee also regroup.\n\n\n\n\n\n","category":"type"},{"location":"tensor/#LinearCombinations.regroup","page":"Tensors","title":"LinearCombinations.regroup","text":"regroup(a, b) -> Regroup\n\nReturn a Regroup object that can be used to rearrange the components of tensors and possibly other structures.\n\nThe actual rearrangement is specified by the two parameters a and b. Both are expression trees consisting of nested tuples of integers. These trees encode the structure of nested tensors, and the integers specify a mapping from the components of the nested source tensor to the nested target tensor. The labels for a and b can in fact be of any isbits type instead of Int, but they must be the same for a and b.\n\nThe return value rg = regroup(a, b) is a callable object. An argument t for rg must be a nested tensor of the same shape as the a tree, and the return value is a Tensor of the same shape as b. The components of the nested tensor t are permuted according to the labels.\n\nIf the components of t have non-zero degrees, then rg(t) additionally has a sign according to the usual sign rule: whenever two ojects x and y are swapped, then this incurs the sign (-1)^(deg(x)*(deg(y))).\n\nMoreover, rg is linear and can be called with linear combinations of tensors.\n\nNote that for each Regroup element rg, Julia generates separate, efficient code for computing rg(t).\n\nSee also swap, regroup_inv, Regroup, LinearCombinations.DefaultCoefftype.\n\nExamples\n\nExample without degrees\n\njulia> rg = regroup(:( (1, (2, 3), 4) ), :( ((3, 1), (4, 2)) ))\nRegroup{(1, (2, 3), 4),((3, 1), (4, 2))}\n\njulia> t = Tensor(\"x\", Tensor(\"y\", \"z\"), \"w\")\n\"x\"⊗(\"y\"⊗\"z\")⊗\"w\"\n\njulia> rg(t)\nLinear1{Tensor{Tuple{Tensor{Tuple{String, String}}, Tensor{Tuple{String, String}}}}, Int64} with 1 term:\n(\"z\"⊗\"x\")⊗(\"w\"⊗\"y\")\n\nExample with degrees\n\nFor simplicity, we define the degree of a String to be its length.\n\njulia> LinearCombinations.deg(x::String) = length(x)\n\njulia> rg(t)   # same rg and t as before\nLinear1{Tensor{Tuple{Tensor{Tuple{String, String}}, Tensor{Tuple{String, String}}}}, Int64} with 1 term:\n-(\"z\"⊗\"x\")⊗(\"w\"⊗\"y\")\n\n\n\n\n\n","category":"function"},{"location":"tensor/#LinearCombinations.regroup_inv","page":"Tensors","title":"LinearCombinations.regroup_inv","text":"regroup_inv(a, b) -> Tuple{Regroup,Regroup}\n\nReturn the tuple (regroup(a, b), regroup(b, a)).\n\nSee also regroup.\n\n\n\n\n\n","category":"function"},{"location":"tensor/#Base.transpose","page":"Tensors","title":"Base.transpose","text":"transpose(t::AbstractTensor{T}) where T <: Tuple{Vararg{AbstractTensor}}\n\nReturn the transpose of a tensor t whose components are tensors of the same length. In other words, the component transpose(t)[i][j] is t[j][i]. If the components t[i][j] have non-zero degrees, a sign is added according to the usual sign rule. The tensor t must have at least one component. If all component tensors are empty, then the empty tensor Tensor() is returned.\n\nThis function is linear.\n\nExamples\n\nExample without signs\n\njulia> t = Tensor(Tensor(\"a\", \"b\", \"c\"), Tensor(\"x\", \"y\", \"z\"))\n(\"a\"⊗\"b\"⊗\"c\")⊗(\"x\"⊗\"y\"⊗\"z\")\n\njulia> transpose(t)\nLinear1{Tensor{Tuple{Tensor{Tuple{String, String}}, Tensor{Tuple{String, String}}, Tensor{Tuple{String, String}}}}, Int64} with 1 term:\n(\"a\"⊗\"x\")⊗(\"b\"⊗\"y\")⊗(\"c\"⊗\"z\")\n\nExample with signs\n\nAs usual, the degree of a String is its length.\n\njulia> LinearCombinations.deg(x::String) = length(x)\n\njulia> transpose(t)   # same t as before\nLinear1{Tensor{Tuple{Tensor{Tuple{String, String}}, Tensor{Tuple{String, String}}, Tensor{Tuple{String, String}}}}, Int64} with 1 term:\n-(\"a\"⊗\"x\")⊗(\"b\"⊗\"y\")⊗(\"c\"⊗\"z\")\n\n\n\n\n\n","category":"function"},{"location":"tensor/#Calling-tensors","page":"Tensors","title":"Calling tensors","text":"","category":"section"},{"location":"tensor/#LinearCombinations.AbstractTensor-Tuple{AbstractTensor}","page":"Tensors","title":"LinearCombinations.AbstractTensor","text":"(tf::AbstractTensor)(tx::AbstractTensor...) -> Tensor\n\nEvaluating an AbstractTensor on other AbstractTensors (with the same number of components) is done componentwise. If the degrees of the components and the maps are not all zero, then the usual sign is introduced: whenever a map f is moved past a component x, then this changes the sign by (-1)^(deg(f)*deg(x)).\n\nExamples\n\nExamples without degrees\n\njulia> @linear f; f(x) = uppercase(x)\nf (generic function with 2 methods)\n\njulia> @linear g; g(x) = lowercase(x)\ng (generic function with 2 methods)\n\njulia> const h = Tensor(f, g)\nf⊗g\n\njulia> a = Linear('x' => 1, 'y' => 2)\nLinear{Char, Int64} with 2 terms:\n'x'+2*'y'\n\njulia> b = Linear('Z' => -1, 'W' => 3)\nLinear{Char, Int64} with 2 terms:\n-'Z'+3*'W'\n\njulia> h(Tensor('x', 'Z'))\nLinear{Tensor{Tuple{Char, Char}}, Int64} with 1 term:\n'X'⊗'z'\n\njulia> h(tensor(a, b))\nLinear{Tensor{Tuple{Char, Char}}, Int64} with 4 terms:\n6*'Y'⊗'w'-2*'Y'⊗'z'+3*'X'⊗'w'-'X'⊗'z'\n\nExamples with degrees\n\nWe again take the length of a String as its degree.\n\njulia> import LinearCombinations: deg\n\njulia> deg(x::String) = length(x);\n\njulia> struct P{T} y::T end; deg(p::P) = deg(p.y);\n\njulia> @linear p::P; (p::P)(x) = x * p.y\n\njulia> p = P(\"pp\"); q = P(\"qqq\")\nP{String}(\"qqq\")\n\njulia> j = Tensor(p, q)\nP{String}(\"pp\")⊗P{String}(\"qqq\")\n\njulia> j(Tensor(\"x\", \"yy\"))\nLinear{Tensor{Tuple{String, String}}, Int64} with 1 term:\n-\"xpp\"⊗\"yyqqq\"\n\njulia> a = Linear(\"x\" => 1, \"yy\" => 2)\nLinear{String, Int64} with 2 terms:\n\"x\"+2*\"yy\"\n\njulia> b = tensor(a, a)\nLinear{Tensor{Tuple{String, String}}, Int64} with 4 terms:\n2*\"yy\"⊗\"x\"+\"x\"⊗\"x\"+4*\"yy\"⊗\"yy\"+2*\"x\"⊗\"yy\"\n\njulia> j(b)\nLinear{Tensor{Tuple{String, String}}, Int64} with 4 terms:\n4*\"yypp\"⊗\"yyqqq\"+2*\"yypp\"⊗\"xqqq\"-2*\"xpp\"⊗\"yyqqq\"-\"xpp\"⊗\"xqqq\"\n\nA multilinear example\n\njulia> @multilinear f; f(x::Char...) = join(x, '#');\n\njulia> @multilinear g; g(x::Char...) = join(x, '@');\n\njulia> f('a', 'p', 'x')\n\"a#p#x\"\n\njulia> Tensor(f, g)(Tensor('a', 'b'), Tensor('p', 'q'), Tensor('x', 'y'))\nLinear{Tensor{Tuple{String, String}}, Int64} with 1 term:\n\"a#p#x\"⊗\"b@q@y\"\n\n\n\n\n\n","category":"method"},{"location":"tensor/#Other-functions-accepting-tensors","page":"Tensors","title":"Other functions accepting tensors","text":"","category":"section"},{"location":"tensor/#LinearCombinations.deg-Tuple{AbstractTensor}","page":"Tensors","title":"LinearCombinations.deg","text":"deg(t::AbstractTensor)\n\nReturn the degree of a tensor, which is the sum of the degrees of its components.\n\nSee also deg.\n\n\n\n\n\n","category":"method"},{"location":"tensor/#Base.:*-Tuple{AbstractTensor, AbstractTensor}","page":"Tensors","title":"Base.:*","text":"*(t1::AbstractTensor , t2::AbstractTensor, ...)\n\nReturn the product of the tensors, computed from the products of its components. Signs are introduced according to the usual sign rule. If all degrees are integers, then the coefficient type is DefaultCoefftype.\n\nThis function is linear.\n\nSee also: LinearCombinations.DefaultCoefftype.\n\nExample\n\njulia> import LinearCombinations: deg\n\njulia> deg(x::String) = length(x);\n\njulia> (s, t) = Tensor(\"ab\", \"c\"), Tensor(\"x\", \"yz\")\n(Tensor(\"ab\", \"c\"), Tensor(\"x\", \"yz\"))\n\njulia> s*t\nLinear{Tensor{Tuple{String, String}}, Int64} with 1 term:\n-\"abx\"⊗\"cyz\"\n\n\n\n\n\n\n","category":"method"},{"location":"tensor/#LinearCombinations.coprod-Tuple{AbstractTensor}","page":"Tensors","title":"LinearCombinations.coprod","text":"coprod(t::T) where T <: AbstractTensor -> Linear{Tensor{Tuple{T,T}}}\n\nReturn the coproduct of a tensor, computed from the coproducts of its components. Signs are introduced according to the usual sign rule. If all degrees are integers, then the coefficient type is DefaultCoefftype.\n\nThis function is linear.\n\nSee also: coprod, LinearCombinations.DefaultCoefftype.\n\nExample\n\njulia> import LinearCombinations: deg, coprod\n\njulia> deg(x::String) = length(x);\n\njulia> coprod(x::String) = Linear(Tensor(x[1:k], x[k+1:end]) => 1 for k in 1:length(x)-1);\n\njulia> coprod(\"abc\")\nLinear{Tensor{Tuple{String, String}}, Int64} with 2 terms:\n\"a\"⊗\"bc\"+\"ab\"⊗\"c\"\n\njulia> t = Tensor(\"abc\", \"xyz\")\n\"abc\"⊗\"xyz\"\n\njulia> coprod(t)\nLinear{Tensor{Tuple{Tensor{Tuple{String, String}}, Tensor{Tuple{String, String}}}}, Int64} with 4 terms:\n(\"a\"⊗\"xy\")⊗(\"bc\"⊗\"z\")-(\"ab\"⊗\"x\")⊗(\"c\"⊗\"yz\")+(\"a\"⊗\"x\")⊗(\"bc\"⊗\"yz\")+(\"ab\"⊗\"xy\")⊗(\"c\"⊗\"z\")\n\n\n\n\n\n","category":"method"},{"location":"tensor/#LinearCombinations.diff-Tuple{AbstractTensor}","page":"Tensors","title":"LinearCombinations.diff","text":"diff(t::T) where T <: AbstractTensor -> Linear{T}\n\nReturn the differential of the tensor t by differentiating each tensor factor at a time and adding signs according to the degrees of the components. The coefficient type is usually DefaultCoefftype. However, if the degrees of the tensor components are not integers, then the coefficient type is chosen such that it can accommodate the signs.\n\nSee also diff, LinearCombinations.DefaultCoefftype.\n\nExample\n\nAs usual, the degree of a string is its length.\n\njulia> import LinearCombinations: deg, diff\n\njulia> deg(x::String) = length(x);\n\njulia> function diff(x::String)\n           if isempty(x) || x[1] == 'D'\n               zero(Linear1{String,Int})\n           else\n               Linear1('D'*x => 1)end\n       end;\n\njulia> dx = diff(\"x\")\nLinear1{String, Int64} with 1 term:\n\"Dx\"\n\njulia> diff(dx)\nLinear1{String, Int64} with 0 terms:\n0\n\njulia> t = Tensor(\"a\", \"bb\", \"ccc\")\n\"a\"⊗\"bb\"⊗\"ccc\"\n\njulia> diff(t)\nLinear{Tensor{Tuple{String, String, String}}, Int64} with 3 terms:\n-\"a\"⊗\"bb\"⊗\"Dccc\"-\"a\"⊗\"Dbb\"⊗\"ccc\"+\"Da\"⊗\"bb\"⊗\"ccc\"\n\n\n\n\n\n","category":"method"},{"location":"#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"#LinearCombinations","page":"Overview","title":"LinearCombinations","text":"LinearCombinations\n\nA Julia package to work with formal linear combinations, tensors and linear as well as multilinear maps. The terms appearing in a linear combination can be of any type, and coefficients can be in any commutative ring with unit. The overall aim of the package is to provide functions that are efficient and easy to use.\n\nSee AbstractLinear, Tensor, @linear, @multilinear.\n\n\n\n\n\n","category":"module"},{"location":"","page":"Overview","title":"Overview","text":"Let us give a few simple examples illustrating the main features of the package. For simplicity we use Char and String as term types and integers, rationals or floating-point numbers as coefficients throughout this documentation.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"We start with some linear combinations. They are of type Linear, which can store any number of term-coefficient pairs. Term type and coefficient type are automatically determined to be Char and Int in the following example.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"using LinearCombinations\na = Linear('x' => 1, 'y' => 2)\nb = Linear('z' => 3, 'w' => -1)\nc = a + 2*b - 'v'\nc['y'], c['u']","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Linear combinations with non-concrete types are also possible.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"p = Linear{AbstractVector,Real}([1,2,3] => 5, 4:6 => 1//2)\n[4,5,6] - 2*p   # [4,5,6] is equal to 4:6","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Next we define a linear function mapping terms to terms. This is done with the help of the macro @linear.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"@linear f; f(x::Char) = uppercase(x)\nf(a)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Another linear function, this time mapping terms to linear combinations.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"@linear g; g(x::Char) = Linear(f(x) => 1, x => -1)\ng(a)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Multiplication is bilinear by default. Recall that multiplying Char or String values in Julia means concatenation.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"a * 'w'\na * b","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The next example is a user-defined bilinear function. Bilinearity is achieved by the macro @multilinear.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"@multilinear h; h(x, y) = x*y*x\nh(a, b)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Here is a user-defined multilinear function with a variable number of arguments.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"@multilinear j; j(x::Char...) = *(x...)\nj(a)\nj(a, b)\nj(a, b, a)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"In the following example we define a tensor and swap the two components of each summand.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"t = tensor(a, b)\nswap(t)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"We finally take the tensor product of the functions f and g and apply it to t.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"const k = Tensor(f, g)\nk(Tensor('x', 'z'))\nk(t)","category":"page"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/#LinearCombinations.Hashed","page":"Internals","title":"LinearCombinations.Hashed","text":"LinearCombinations.Hashed{T}\n\nHashed{T}(x::T) is a wrapper that stores hash(x) along with x. Computing the hash of such an element returns the stored hash value.\n\nSee also LinearCombinations.unhash.\n\n\n\n\n\n","category":"type"},{"location":"internals/#LinearCombinations.unhash","page":"Internals","title":"LinearCombinations.unhash","text":"LinearCombinations.unhash(x)\n\nReturn the argument unless it is of the form Hashed{T}(y), in which case y is returned.\n\nSee also LinearCombinations.Hashed.\n\n\n\n\n\n","category":"function"},{"location":"internals/#LinearCombinations.unval","page":"Internals","title":"LinearCombinations.unval","text":"LinearCombinations.unval(x)\n\nReturn c if the argument x is of type Val{c} and x itself otherwise.\n\nThis can be used to write type-stable code for the coefftype keyword argument to linear and multilinear functions.\n\nSee also @linear, @linear_kw, @multilinear.\n\nExamples\n\njulia> LinearCombinations.unval(Char)\nChar\n\njulia> LinearCombinations.unval(Val(Char))\nChar\n\n\n\n\n\n","category":"function"},{"location":"internals/#LinearCombinations.Zero","page":"Internals","title":"LinearCombinations.Zero","text":"Zero\n\nZero is a type whose only value Zero() behaves like 0, but allows for simplification at compile time.\n\n\n\n\n\n","category":"type"},{"location":"internals/#LinearCombinations.LinearStyle","page":"Internals","title":"LinearCombinations.LinearStyle","text":"LinearCombinations.LinearStyle\n\nThe broadcasting style used for linear combinations.\n\nSee also @linear_broadcastable.\n\n\n\n\n\n","category":"type"},{"location":"extensions/#Linear-and-multilinear-functions","page":"Linear and multilinear functions","title":"Linear and multilinear functions","text":"","category":"section"},{"location":"extensions/#Linear-extensions","page":"Linear and multilinear functions","title":"Linear extensions","text":"","category":"section"},{"location":"extensions/#LinearCombinations.@linear","page":"Linear and multilinear functions","title":"LinearCombinations.@linear","text":"@linear f\n\nThis macro defines a linear extension of the function (or callable object) f. More specifically, it defines a new method f(a::AbstractLinear{T,R}; kw...) where {T,R} that returns the linear combination obtained by summing up c*f(x) for all term-coefficient pairs x => c appearing in a.\n\nThe new method recognizes the following keyword arguments:\n\ncoefftype:   This optional keyword argument specifies the coefficient type of the linear combination returned   by f(a) if the keyword argument addto is not present. If coefftype is also not specified   and f(x::T) is a term (as opposed to a linear combination), then coefftype is set to R.   If f(x::T) <: AbstractLinear, say with coefficient type S, then promote_type(R, S)   is chosen as the new coefficient type. If the addto keyword is present, then coefftype is ignored.\nBecause of the way Julia handles keyword arguments, the form f(a; coefftype = Int) is not type-stable.   Type stability can be achieved by saying f(a; coefftype = Val(Int)).\naddto::AbstractLinear:   If given, the sum of all terms c*f(x) is added to addto, and the result is returned.   This avoids allocating a new linear combination each time f is called with an AbstractLinear argument.   The default value for addto is Linear{U,coefftype}. Here U is the return type of f(x::T)   if this return type is not a subtype of AbstractLinear and the term type of the return values otherwise.\ncoeff:   This optional keyword argument allows to efficiently compute scalar multiples of f(a). More precisely,   f(a; coeff = c) returns c*f(a), and f(a; addto = b, coeff = c) adds c*f(a) to b and returns   this new value.\nsizehint::Bool = true:   The new method for f may call sizehint! for addto to pre-allocate room for the new terms.   This keyword argument permits to turn pre-allocation off.\n\nAll other keyword arguments are passed on to f(x). With the macro @linear_kw one can make f(a) pass the special keyword arguments listed above on to f(x), too.\n\nSee also @multilinear, sizehint!, @linear_kw, keeps_filtered.\n\nExamples\n\nLinear extension of a function returning a term\n\njulia> f(x) = uppercase(x); @linear f\nf (generic function with 2 methods)\n\njulia> a = Linear('x' => 1, 'y' => 2)\nLinear{Char, Int64} with 2 terms:\n'x'+2*'y'\n\njulia> f(a)\nLinear{Char, Int64} with 2 terms:\n2*'Y'+'X'\n\njulia> f(a; coefftype = Float64)\nLinear{Char, Float64} with 2 terms:\n2.0*'Y'+'X'\n\njulia> b = Linear('z' => 3); f(a; addto = b, coeff = -1); b\nLinear{Char, Int64} with 3 terms:\n-2*'Y'-'X'+3*'z'\n\nLinear extension of a function returning a linear combination\n\njulia> g(x) = Linear(x*x => 1.0, string(x) => -1.0); @linear g\ng (generic function with 2 methods)\n\njulia> g(\"x\"), g(\"\")\n(Linear{String, Float64}(\"xx\" => 1.0, \"x\" => -1.0), Linear{String, Float64}())\n\njulia> g(a)   # same a as before\nLinear{String, Float64} with 4 terms:\n\"xx\"-\"x\"+2.0*\"yy\"-2.0*\"y\"\n\njulia> g(a; coefftype = Val(Int), coeff = 3.0)\nLinear{String, Int64} with 4 terms:\n3*\"xx\"-3*\"x\"+6*\"yy\"-6*\"y\"\n\nLinear extension of a callable object\n\njulia> struct P y::String end\n\njulia> (p::P)(x) = p.y*x*p.y; @linear p::P\n\njulia> p = P(\"w\"); p(a)   # same a as before\nLinear{String, Int64} with 2 terms:\n\"wxw\"+2*\"wyw\"\n\n\n\n\n\n","category":"macro"},{"location":"extensions/#LinearCombinations.LinearExtension","page":"Linear and multilinear functions","title":"LinearCombinations.LinearExtension","text":"LinearExtension{F}\n\nThis type is the linear extension of the given type F.\n\nExamples\n\njulia> const g = LinearExtension(uppercase)\nLinearExtension(uppercase)\n\njulia> g('x')\n'X': ASCII/Unicode U+0058 (category Lu: Letter, uppercase)\n\njulia> a = Linear('x' => 1, 'y' => 2); g(a; coeff = 3)\nLinear{Char, Int64} with 2 terms:\n6*'Y'+3*'X'\n\n\n\n\n\n","category":"type"},{"location":"extensions/#LinearCombinations.matrixrepr","page":"Linear and multilinear functions","title":"LinearCombinations.matrixrepr","text":"matrixrepr(f, b1::AbstractBasis, b0::AbstractBasis, ::Type{R})) where R\n\nReturn a matrix representing the linear map f with respect to the bases b0 (source) and b1 (target). Coefficients have the type R.\n\nSee also matrixrepr!.\n\nExample\n\njulia> @linear f; f(x) = Linear(uppercase(x) => 1, 'A' => 1)\nf (generic function with 2 methods)\n\njulia> matrixrepr(f, Basis('A':'C'), Basis('a':'c'), Int)\n3×3 Matrix{Int64}:\n 2  1  1\n 0  1  0\n 0  0  1\n\n\n\n\n\n","category":"function"},{"location":"extensions/#LinearCombinations.matrixrepr!","page":"Linear and multilinear functions","title":"LinearCombinations.matrixrepr!","text":"matrixrepr!(f, a::AbstractMatrix, b1::AbstractBasis, b0::AbstractBasis; iszero::Bool = false) -> a\n\nCompute a matrix representing the linear map f with with respect to the bases b0 (source) and b1 (target). Store the result in a and return a. If the keyword argument iszero is true, then the matrix a is not first initialized with zeros.\n\nSee also matrixrepr.\n\n\n\n\n\n","category":"function"},{"location":"extensions/#LinearCombinations.diff","page":"Linear and multilinear functions","title":"LinearCombinations.diff","text":"diff(x)\n\nThe differential of x.\n\nThe module LinearCombinations only defines the linear extension of diff, but no methods for terms. The only exception is diff for tensors.\n\nSee also diff(t::AbstractTensor).\n\n\n\n\n\n","category":"function"},{"location":"extensions/#LinearCombinations.coprod","page":"Linear and multilinear functions","title":"LinearCombinations.coprod","text":"coprod(x)\n\nThe coproduct (or comultiplication) of x, which is assumed to be an element of a coalgebra.\n\nThe module LinearCombinations only defines the linear extension of coprod, but no methods for terms, except for tensors.\n\nSee also coprod(t::AbstractTensor).\n\n\n\n\n\n","category":"function"},{"location":"extensions/#Multilinear-extensions","page":"Linear and multilinear functions","title":"Multilinear extensions","text":"","category":"section"},{"location":"extensions/#LinearCombinations.@multilinear","page":"Linear and multilinear functions","title":"LinearCombinations.@multilinear","text":"@multilinear f\n@multilinear f f0\n\nThis macro defines a multilinear extension of the function f (or f0). This is analogous to @linear f. The new methods accepts both terms and linear combinations as arguments. It linearly expands all arguments that are linear combinations and then calls f for each combination of terms. If f0 is specified, then f0 is called instead to evaluate terms.\n\nThe new method always returns a linear combination (of type Linear unless this is overriden by the addto keyword). The term type is inferred from the return type of f (or f0) with terms as arguments. The coefficient type is computed by promoting the coefficient types of all AbstractLinear arguments. In case f (or f0) returns a linear combination for term arguments, that coefficient type is also taken into account.\n\nIn order to catch all possible combinations of terms and linear combinations, @multilinear f and @multilinear f f0 define a single new method f(x...; kw...) that matches all argument types. (This is different from @linear.) Hence, if f0 is not given, then the methods for f that evaluate terms must have a non-generic signature. If instead the signature also is f(x::Any...), then this method is overwritten, resulting in an error when f is called.\n\nThe new method defined by @multilinear accepts all keyword arguments discussed for @linear. Unknown keyword arguments are passed on to the call for term evaluation. The macro @linear_kw works as for linear functions.\n\nIf the two-argument version of @multilinear is used, then typically there is no other method for f. Hence f returns a linear combination for all arguments in this case. If all arguments are terms and also f0 returns a term, then the coefficient type is LinearCombinations.DefaultCoefftype. For the one-argument version there must be at least one other method as discussed above. So f may not return a linear combination for all arguments.\n\nSee also @linear, @linear_kw, LinearCombinations.DefaultCoefftype.\n\nExamples\n\nBilinear extension of a function returning a term\n\njulia> f(x::Char, y::String) = x*y; @multilinear f\n\njulia> a, b = Linear('x' => 1, 'y' => 2), Linear(\"z\" => 1.0, \"w\" => -1.0)\n(Linear{Char, Int64}('x' => 1, 'y' => 2), Linear{String, Float64}(\"w\" => -1.0, \"z\" => 1.0))\n\njulia> f(a, \"z\")\nLinear{String, Int64} with 2 terms:\n2*\"yz\"+\"xz\"\n\njulia> f('x', b)\nLinear{String, Float64} with 2 terms:\n-\"xw\"+\"xz\"\n\njulia> f(a, b)\nLinear{String, Float64} with 4 terms:\n-\"xw\"+2.0*\"yz\"-2.0*\"yw\"+\"xz\"\n\nBilinear extension of a function returning a linear combination\n\njulia> f(x::Char, y::String) = Linear(x*y => BigInt(1), y*x => BigInt(-1)); @multilinear f\n\njulia> f(a, b)   # same a and b as before\nLinear{String, BigFloat} with 8 terms:\n-2.0*\"zy\"-\"xw\"-\"zx\"+2.0*\"yz\"+\"wx\"-2.0*\"yw\"+\"xz\"+2.0*\"wy\"\n\njulia> typeof(ans)\nLinear{String, BigFloat}\n\nMultilinear extension of a function\n\njulia> g(xs::Union{Char,String}...) = *(xs...); @multilinear g\n\njulia> g(a)   # same a and b as before\nLinear{String, Int64} with 2 terms:\n\"x\"+2*\"y\"\n\njulia> g(a, b)\nLinear{String, Float64} with 4 terms:\n-\"xw\"+2.0*\"yz\"-2.0*\"yw\"+\"xz\"\n\njulia> g(a, b, a)\nLinear{String, Float64} with 8 terms:\n-\"xwx\"+\"xzx\"+4.0*\"yzy\"+2.0*\"xzy\"+2.0*\"yzx\"-2.0*\"ywx\"-2.0*\"xwy\"-4.0*\"ywy\"\n\nMultilinear extension using the two-argument version of @multilinear\n\njulia> @multilinear(h, *)\n\njulia> h(a, b; coeff = 2)   # same a and b as before\nLinear{String, Float64} with 4 terms:\n-2.0*\"xw\"+4.0*\"yz\"-4.0*\"yw\"+2.0*\"xz\"\n\n\n\n\n\n","category":"macro"},{"location":"extensions/#LinearCombinations.MultilinearExtension","page":"Linear and multilinear functions","title":"LinearCombinations.MultilinearExtension","text":"MultilinearExtension(f)\nMultilinearExtension(f, name)\n\nAn element of this type is a multilinear extension of f. One can additionally specify the name displayed for it.\n\nExample\n\njulia> a, b = Linear('x' => 1, 'y' => 2), Linear(\"z\" => 1.0, \"w\" => -1.0)\n(Linear{Char, Int64}('x' => 1, 'y' => 2), Linear{String, Float64}(\"w\" => -1.0, \"z\" => 1.0))\n\njulia> const concat = MultilinearExtension(*, \"concat\")\nconcat\n\njulia> concat(a, b)\nLinear{String, Float64} with 4 terms:\n-\"xw\"+2.0*\"yz\"-2.0*\"yw\"+\"xz\"\n\n\n\n\n\n","category":"type"},{"location":"extensions/#LinearCombinations.mul","page":"Linear and multilinear functions","title":"LinearCombinations.mul","text":"LinearCombinations.mul(x1::Any, x2::Any, ...)\n\nReturn the product of the arguments. This is the multilinear extension of *.\n\nThe new name avoids type piracy since mul accepts all argument types.\n\n\n\n\n\n","category":"constant"},{"location":"extensions/#Common-functionality","page":"Linear and multilinear functions","title":"Common functionality","text":"","category":"section"},{"location":"extensions/#LinearCombinations.@linear_kw","page":"Linear and multilinear functions","title":"LinearCombinations.@linear_kw","text":"@linear_kw function def\n\n@linear_kw scans a function definition for the keywords coefftype, addto, coeff and sizehint and makes them known to the LinearCombinations package. This allows to write performant code. Not all keywords have to present. However, addto and coeff only have an effect if used together.\n\nSee also LinearCombinations.has_coefftype, LinearCombinations.has_addto_coeff, LinearCombinations.has_isfiltered, LinearCombinations.has_sizehint, LinearCombinations.unval.\n\nExample\n\nConsider the following two functions:\n\nf(x::Char) = Linear(uppercase(x) => 1, x => -1)\n\n@linear f\n\nusing LinearCombinations: unval   # unwraps a Val argument\n\n@linear_kw function g(x::Char;\n        coefftype = Int,\n        addto = zero(Linear{Char,unval(coefftype)}),\n        coeff = 1)\n    addmul!(addto, uppercase(x), coeff)\n    addmul!(addto, x, -coeff)\n    addto\nend\n\n@linear g\n\nThe linear extensions are functionally equivalent,  but g will be much faster than f.\n\njulia> a = Linear('x' => 1, 'y' => 2)\nLinear{Char, Int64} with 2 terms:\n'x'+2*'y'\n\njulia> f(a; coefftype = Float64, coeff = 2)\nLinear{Char, Float64} with 4 terms:\n4.0*'Y'-2.0*'x'-4.0*'y'+2.0*'X'\n\njulia> g(a; coefftype = Float64, coeff = 2)\nLinear{Char, Float64} with 4 terms:\n4.0*'Y'-2.0*'x'-4.0*'y'+2.0*'X'\n\nTest whether keywords have been registered:\n\njulia> using LinearCombinations: has_coefftype, has_addto_coeff, has_sizehint\n\njulia> has_coefftype(g, Char), has_addto_coeff(g, Char), has_sizehint(g, Char)\n(true, true, false)\n\n\n\n\n\n","category":"macro"},{"location":"extensions/#LinearCombinations.DefaultCoefftype","page":"Linear and multilinear functions","title":"LinearCombinations.DefaultCoefftype","text":"const LinearCombinations.DefaultCoefftype = Int\n\nThe coefficient type use by LinearCombinations if no other coefficient type information is available.\n\n\n\n\n\n","category":"type"},{"location":"extensions/#LinearCombinations.linear_filter","page":"Linear and multilinear functions","title":"LinearCombinations.linear_filter","text":"LinearCombinations.linear_filter(x) -> Bool\n\nReturn true if the term x is to be stored in linear combinations and false if it is to be dropped.\n\nThe effect of this is that linear combinations don't live in the vector space (or free module) spanned by all possible terms, but rather in the quotient by the subspace (or submodule) spanned by the terms for which linear_filter returns false. Setting coefficients for terms that are divided out is allowed, but has no effect.\n\nThe default return value of linear_fiilter is true for all arguments, so that nothing is divided out.\n\nSee also keeps_filtered, LinearCombinations.termcoeff.\n\nExample\n\njulia> LinearCombinations.linear_filter(x::Char) = islowercase(x)\n\njulia> a = Linear('x' => 1, 'Y' => 2)\nx\n\njulia> a['Z'] = 3\n3\n\njulia> a\nx\n\n\n\n\n\n","category":"function"},{"location":"extensions/#LinearCombinations.keeps_filtered","page":"Linear and multilinear functions","title":"LinearCombinations.keeps_filtered","text":"keeps_filtered(f, types...) -> Bool\n\nReturn true if the following is satisfied, and false otherwise: Whenever the function f is called with arguments of types types and returns a single term y, then linear_filter(y) == true holds.\n\nBy default, keeps_filtered returns false for all arguments. This can be changed to avoid unneccesary (and possibly expensive) calls to linear_filter. Note that if f returns a linear combination when called with term arguments, then all terms appearing in this linear combination satisfy the condition above anyway. The setting for keeps_filtered doesn't matter in this case.\n\nSee also LinearCombinations.linear_filter.\n\n\n\n\n\n","category":"function"},{"location":"extensions/#LinearCombinations.termcoeff","page":"Linear and multilinear functions","title":"LinearCombinations.termcoeff","text":"LinearCombinations.termcoeff(xc::Pair) -> Pair\n\nTransform a term-coefficient pair into the format that is stored in a linear combination.\n\nThis function is called for every term-coefficient pair that enters a linear combination. The default is to return a pair x => c unchanged. This can be changed in special situations where one wants to normalize terms and coefficients. Note that termcoeff is called only if linear_filter(x) is true.\n\nSee also linear_filter.\n\nExample\n\nWe show how to convert term-coefficient pairs with an uppercase letter to lowercase letters together with the negative coefficient.\n\njulia> function LinearCombinations.termcoeff((x, c)::Pair{Char})\n           isuppercase(x) ? lowercase(x) => -c : x => c\n       end\n\njulia> a = Linear('x' => 1, 'Y' => 2)\nLinear{Char, Int64} with 2 terms:\n'x'-2*'y'\n\njulia> a['y'], a['Y']\n(-2, 2)\n\njulia> a['Y'] = 3; a\nLinear{Char, Int64} with 2 terms:\n'x'-3*'y'\n\njulia> a + 'X'\nLinear{Char, Int64} with 1 term:\n-3*'y'\n\n\n\n\n\n","category":"function"},{"location":"extensions/#LinearCombinations.has_coefftype","page":"Linear and multilinear functions","title":"LinearCombinations.has_coefftype","text":"LinearCombinations.has_coefftype(f, types...) -> Bool\n\nReturn true if the method for f with signature given by types is known to support the keyword argument coefftype. The macro @linear_kw is used to make this keyword known to the LinearCombinations package.\n\nSee also @linear_kw, LinearCombinations.has_addto_coeff, LinearCombinations.has_isfiltered, LinearCombinations.has_sizehint.\n\n\n\n\n\n","category":"function"},{"location":"extensions/#LinearCombinations.has_addto_coeff","page":"Linear and multilinear functions","title":"LinearCombinations.has_addto_coeff","text":"LinearCombinations.has_addto_coeff(f, types...) -> Bool\n\nReturn true if the method for f with signature given by types is known to support the keyword arguments addto and coeff. The macro @linear_kw is used to make these keywords known to the LinearCombinations package.\n\nSee also @linear_kw, LinearCombinations.has_coefftype, LinearCombinations.has_isfiltered, LinearCombinations.has_sizehint.\n\n\n\n\n\n","category":"function"},{"location":"extensions/#LinearCombinations.has_isfiltered","page":"Linear and multilinear functions","title":"LinearCombinations.has_isfiltered","text":"LinearCombinations.has_isfiltered(f, types...) -> Bool\n\nReturn true if the method for f with signature given by types is known to support the keyword argument is_filtered::Bool. The macro @linear_kw is used to make this keyword known to the LinearCombinations package.\n\nThe keyword argument is_filtered = true for a linear or multilinear function f indicates this potentially expensive test can be skipped when evaluating f.\n\nSee also @linear_kw, LinearCombinations.has_coefftype, LinearCombinations.has_addto_coeff, LinearCombinations.has_sizehint, keeps_filtered.\n\n\n\n\n\n","category":"function"},{"location":"extensions/#LinearCombinations.has_sizehint","page":"Linear and multilinear functions","title":"LinearCombinations.has_sizehint","text":"LinearCombinations.has_sizehint(f, types...) -> Bool\n\nReturn true if the method for f with signature given by types is known to support the keyword argument sizehint. The macro @linear_kw is used to make this keyword known to the LinearCombinations package.\n\nSee also @linear_kw, LinearCombinations.has_coefftype, LinearCombinations.has_addto_coeff, LinearCombinations.has_isfiltered,\n\n\n\n\n\n","category":"function"},{"location":"extensions/#Switching-between-linear-and-multilinear-maps","page":"Linear and multilinear functions","title":"Switching between linear and multilinear maps","text":"","category":"section"},{"location":"extensions/#LinearCombinations.TensorSlurp","page":"Linear and multilinear functions","title":"LinearCombinations.TensorSlurp","text":"TensorSlurp(f)\n\nTensorSlurp turns a linear function acting on Tensor terms into a multilinear function. This is similar to slurping in Julia.\n\nThe new function always returns a linear combination, even if none of the arguments is a linear combination. It recognizes all keyword arguments discussed for @linear. Unknown keyword arguments are passed on to f.\n\nSee also Tensor, tensor, TensorSplat, @linear.\n\nExamples\n\nWe use swap as an example of a function acting on tensors.\n\njulia> const f = TensorSlurp(swap)\nTensorSlurp(Regroup{(1, 2),(2, 1)})\n\njulia> a = Linear('x' => 1, 'y' => 2)\nLinear{Char, Int64} with 2 terms:\n'x'+2*'y'\n\njulia> b = Linear(\"w\" => 3, \"z\" => -1)\nLinear{String, Int64} with 2 terms:\n3*\"w\"-\"z\"\n\njulia> c = tensor(a, b)\nLinear{Tensor{Tuple{Char, String}}, Int64} with 4 terms:\n3*'x'⊗\"w\"-'x'⊗\"z\"-2*'y'⊗\"z\"+6*'y'⊗\"w\"\n\njulia> swap(c)\nLinear{Tensor{Tuple{String, Char}}, Int64} with 4 terms:\n-\"z\"⊗'x'-2*\"z\"⊗'y'+6*\"w\"⊗'y'+3*\"w\"⊗'x'\n\njulia> f(a, b)\nLinear{Tensor{Tuple{String, Char}}, Int64} with 4 terms:\n-\"z\"⊗'x'-2*\"z\"⊗'y'+6*\"w\"⊗'y'+3*\"w\"⊗'x'\n\njulia> f(a, b; addto = swap(c), coeff = -1)\nLinear{Tensor{Tuple{String, Char}}, Int64} with 0 terms:\n0\n\n\n\n\n\n","category":"type"},{"location":"extensions/#LinearCombinations.TensorSplat","page":"Linear and multilinear functions","title":"LinearCombinations.TensorSplat","text":"TensorSplat(f)\n\nTensorSplat turns a multilinear function f into a linear function acting on terms of type Tensor. This is similar to splatting in Julia.\n\nWhen called with an argument of type Tensor, the new function returns the the value of f on the components of the tensor (which may or may not be a linear combination). All keyword arguments are passed on to f in this case.\n\nWhen called with a linear combination as argument, the new function returns a linear combination. It recognizes all keyword arguments discussed for @linear. Unknown keyword arguments are passed on to f.\n\nSee also Tensor, tensor, TensorSlurp, @linear.\n\nExamples\n\njulia> const f = MultilinearExtension(*)\nMultilinearExtension(*)\n\njulia> const g = TensorSplat(f)\nTensorSplat(MultilinearExtension(*))\n\njulia> a = Linear('x' => 1, 'y' => 2)\nLinear{Char, Int64} with 2 terms:\n'x'+2*'y'\n\njulia> b = Linear(\"w\" => 3, \"z\" => -1)\nLinear{String, Int64} with 2 terms:\n3*\"w\"-\"z\"\n\njulia> f(a, b)\nLinear{String, Int64} with 4 terms:\n3*\"xw\"-2*\"yz\"+6*\"yw\"-\"xz\"\n\njulia> c = tensor(a, b)\nLinear{Tensor{Tuple{Char, String}}, Int64} with 4 terms:\n3*'x'⊗\"w\"-'x'⊗\"z\"-2*'y'⊗\"z\"+6*'y'⊗\"w\"\n\njulia> g(c)\nLinear{String, Int64} with 4 terms:\n3*\"xw\"-2*\"yz\"+6*\"yw\"-\"xz\"\n\njulia> g(c; addto = f(a, b), coeff = -1)\nLinear{String, Int64} with 0 terms:\n0\n\n\n\n\n\n","category":"type"}]
}
