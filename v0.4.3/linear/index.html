<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Linear combinations · LinearCombinations.jl</title><meta name="title" content="Linear combinations · LinearCombinations.jl"/><meta property="og:title" content="Linear combinations · LinearCombinations.jl"/><meta property="twitter:title" content="Linear combinations · LinearCombinations.jl"/><meta name="description" content="Documentation for LinearCombinations.jl."/><meta property="og:description" content="Documentation for LinearCombinations.jl."/><meta property="twitter:description" content="Documentation for LinearCombinations.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">LinearCombinations.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li class="is-active"><a class="tocitem" href>Linear combinations</a><ul class="internal"><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Basic-methods"><span>Basic methods</span></a></li><li><a class="tocitem" href="#Arithmetic"><span>Arithmetic</span></a></li><li><a class="tocitem" href="#Calling-linear-combinations"><span>Calling linear combinations</span></a></li><li><a class="tocitem" href="#Broadcasting"><span>Broadcasting</span></a></li><li><a class="tocitem" href="#AbstractLinear-interface"><span><code>AbstractLinear</code> interface</span></a></li></ul></li><li><a class="tocitem" href="../basis/">Bases</a></li><li><a class="tocitem" href="../tensor/">Tensors</a></li><li><a class="tocitem" href="../extensions/">Linear and multilinear functions</a></li><li><a class="tocitem" href="../basics/">Basic functions</a></li><li><a class="tocitem" href="../internals/">Internals</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Linear combinations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Linear combinations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/matthias314/LinearCombinations.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/matthias314/LinearCombinations.jl/blob/master/docs/src/linear.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Linear-combinations"><a class="docs-heading-anchor" href="#Linear-combinations">Linear combinations</a><a id="Linear-combinations-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-combinations" title="Permalink"></a></h1><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearCombinations.AbstractLinear" href="#LinearCombinations.AbstractLinear"><code>LinearCombinations.AbstractLinear</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">L(xc::Pair...; is_filtered = false; kw...) where L &lt;: AbstractLinear
L(itr; is_filtered = false; kw...) where L &lt;: AbstractLinear</code></pre><p><code>AbstractLinear{T,R}</code> is the supertype of all linear combinations with term type <code>T</code> and coefficient type <code>R</code>.</p><p>A constructor for a subtype <code>L &lt;: AbstractLinear</code> constructs a linear combination of type <code>L</code> out of the given term-coefficient pairs of the form <code>x =&gt; c</code> where <code>x</code> is the term and <code>c</code> the coefficient, or out of the pairs provided by the iterator <code>itr</code>. It must be possible to convert all terms and coefficients to the chosen term type and coefficient type, respectively.</p><p>Neither the term type nor the coefficient type need to be concrete. (Of course, concrete types lead to better performance.) If the coefficient type and possibly also the term type are not specified, the constructor tries to determine them using <code>promote_type</code> (for coefficients) and <code>promote_typejoin</code> (for terms).</p><p>If two or more term-coefficient pairs are given with the same term, then the corresponding coefficients are added up. This is different from dictionaries, where any key-value pair overrides previous pairs with the same key. However, the implemented behavior is more useful for linear combinations.</p><p>For specialized applications, terms and coefficients can be processed with <code>linear_filter</code> and <code>termcoeff</code> before being stored in a linear combination. The keyword argument <code>is_filtered</code> controls whether <code>linear_filter</code> is called for each term.</p><p>By default, linear combinations are displayed in a human-readable form with a limited number of terms. Dedicated <code>show</code> methods display all terms of a linear combination or return an expression that Julia can parse as input. See the examples below.</p><p>See also <a href="#LinearCombinations.Linear"><code>Linear</code></a>, <a href="#LinearCombinations.DenseLinear"><code>DenseLinear</code></a>, <a href="#LinearCombinations.Linear1"><code>Linear1</code></a>, <a href="../extensions/#LinearCombinations.linear_filter"><code>linear_filter</code></a>, <a href="../extensions/#LinearCombinations.termcoeff"><code>LinearCombinations.termcoeff</code></a>, <code>Base.show</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Linear(&#39;x&#39; =&gt; 1, &#39;y&#39; =&gt; 2)
Linear{Char, Int64} with 2 terms:
&#39;x&#39;+2*&#39;y&#39;

julia&gt; Linear(x =&gt; c for (c, x) in enumerate(&#39;u&#39;:&#39;z&#39;))
Linear{Char, Int64} with 6 terms:
3*&#39;w&#39;+2*&#39;v&#39;+4*&#39;x&#39;+&#39;u&#39;+5*&#39;y&#39;+6*&#39;z&#39;

julia&gt; Linear{Char,Int}(&#39;x&#39; =&gt; 1, &#39;y&#39; =&gt; Int8(0), &#39;x&#39; =&gt; 3.0)
Linear{Char, Int64} with 1 term:
4*&#39;x&#39;

julia&gt; a = Linear(&#39;x&#39; =&gt; BigInt(1), &quot;yz&quot; =&gt; 2.0)
Linear{Any, BigFloat} with 2 terms:
&#39;x&#39;+2.0*&quot;yz&quot;</code></pre><p>Iterating over a linear combination yields all non-zero term-coefficient pairs. Hence a linear combination can itself be used an argument to an <code>AbstractLinear</code> constructor.</p><pre><code class="language-julia-repl hljs">julia&gt; Linear{Union{Char,String}}(a)   # same a as before
Linear{Union{Char, String}, BigFloat} with 2 terms:
&#39;x&#39;+2.0*&quot;yz&quot;</code></pre><p>Various forms to display a linear combination.</p><pre><code class="language-julia-repl hljs">julia&gt; a = Linear(x =&gt; 1 for x in &#39;a&#39;:&#39;z&#39;)
Linear{Char, Int64} with 26 terms:
&#39;n&#39;+&#39;f&#39;+&#39;w&#39;+&#39;d&#39;+&#39;e&#39;+&#39;o&#39;+&#39;h&#39;+&#39;j&#39;+&#39;i&#39;+&#39;k&#39;+&#39;r&#39;+&#39;s&#39;+&#39;t&#39;+&#39;q&#39;+&#39;y&#39;+&#39;a&#39;+&#39;c&#39;+&#39;p&#39;+&#39;m&#39;+&#39;z&#39;±⋯

julia&gt; show(stdout, MIME&quot;text/plain&quot;(), a)  # all terms
Linear{Char, Int64} with 26 terms:
&#39;n&#39;+&#39;f&#39;+&#39;w&#39;+&#39;d&#39;+&#39;e&#39;+&#39;o&#39;+&#39;h&#39;+&#39;j&#39;+&#39;i&#39;+&#39;k&#39;+&#39;r&#39;+&#39;s&#39;+&#39;t&#39;+&#39;q&#39;+&#39;y&#39;+&#39;a&#39;+&#39;c&#39;+&#39;p&#39;+&#39;m&#39;+&#39;z&#39;+&#39;g&#39;+&#39;v&#39;+&#39;l&#39;+&#39;u&#39;+&#39;x&#39;+&#39;b&#39;

julia&gt; b = Linear(&#39;a&#39; =&gt; 1, &#39;y&#39; =&gt; 2)
Linear{Char, Int64} with 2 terms:
&#39;a&#39;+2*&#39;y&#39;

julia&gt; show(b)  # can be parsed as input
Linear{Char, Int64}(&#39;a&#39; =&gt; 1, &#39;y&#39; =&gt; 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/LinearCombinations.jl/blob/b2b18e0d07916044c7b6d3151984521192d486f1/src/abstractlinear.jl#L9-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearCombinations.Linear" href="#LinearCombinations.Linear"><code>LinearCombinations.Linear</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Linear{T,R} &lt;: AbstractLinear{T,R}

Linear{T,R}(itr)</code></pre><p>Construct a linear combination of type <code>Linear</code> with term type <code>T</code> and coefficient type <code>R</code> out of the term-coefficient pairs provided by the iterator <code>itr</code>.</p><p>Linear combinations of this type are sparse in the sense that terms and (non-zero) coefficients are internally stored in a dictionary.</p><p>Other ways to use this constructor are discussed under <code>AbstractLinear</code>.</p><p>See also <a href="#LinearCombinations.AbstractLinear"><code>AbstractLinear</code></a>, <a href="#LinearCombinations.DenseLinear"><code>DenseLinear</code></a>, <a href="#LinearCombinations.Linear1"><code>Linear1</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/LinearCombinations.jl/blob/b2b18e0d07916044c7b6d3151984521192d486f1/src/linear.jl#L7-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearCombinations.DenseLinear" href="#LinearCombinations.DenseLinear"><code>LinearCombinations.DenseLinear</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DenseLinear{T,R} &lt;: AbstractLinear{T,R}

DenseLinear{T,R}(itr; basis::Basis)</code></pre><p>Construct a linear combination of type <code>DenseLinear</code> with term type <code>T</code> and coefficient type <code>R</code> out of the term-coefficient pairs provided by the iterator <code>itr</code>.</p><p>Linear combinations of this type are internally stored as a <code>Vector</code> (or, more generally, an <code>AbstractArray</code>). The mandatory keyword argument <code>basis</code> is used to translate between terms and entries of the <code>Vector</code> (or <code>Array</code>). Operations involving two <code>DenseLinear</code> elements are much faster when the two bases are identical (in the sense of <code>===</code>).</p><p>Other ways to use this constructor are discussed under <code>AbstractLinear</code>.</p><p>See also <a href="../basis/#LinearCombinations.Basis"><code>Basis</code></a>, <a href="#LinearCombinations.AbstractLinear"><code>AbstractLinear</code></a>, <a href="#LinearCombinations.Linear"><code>Linear</code></a>, <a href="#LinearCombinations.Linear1"><code>Linear1</code></a>, <a href="#LinearCombinations.basis"><code>basis</code></a>, <a href="#LinearCombinations.coordinates"><code>coordinates</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; azbasis = Basis(&#39;a&#39;:&#39;z&#39;)
Basis(&#39;a&#39;:1:&#39;z&#39;)

julia&gt; a = DenseLinear(&#39;x&#39; =&gt; 1, &#39;y&#39; =&gt; 2; basis = azbasis)
DenseLinear{Char, Int64} with 2 terms:
&#39;x&#39;+2*&#39;y&#39;

julia&gt; a + &#39;z&#39;
DenseLinear{Char, Int64} with 3 terms:
&#39;x&#39;+2*&#39;y&#39;+&#39;z&#39;

julia&gt; a + &#39;X&#39;
ERROR: KeyError: key &#39;X&#39; not found
[...]

julia&gt; b = DenseLinear(&#39;x&#39; =&gt; -1, &#39;z&#39; =&gt; 3; basis = azbasis)
DenseLinear{Char, Int64} with 2 terms:
-&#39;x&#39;+3*&#39;z&#39;

julia&gt; a + b
Linear{Char, Int64} with 2 terms:
2*&#39;y&#39;+3*&#39;z&#39;

julia&gt; c = DenseLinear(&#39;a&#39; =&gt; 5; basis = Basis(&#39;a&#39;:&#39;c&#39;))
DenseLinear{Char, Int64} with 1 term:
5*&#39;a&#39;

julia&gt; add!(a, c)
DenseLinear{Char, Int64} with 3 terms:
5*&#39;a&#39;+&#39;x&#39;+2*&#39;y&#39;

julia&gt; add!(c, a)
ERROR: KeyError: key &#39;x&#39; not found</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/LinearCombinations.jl/blob/b2b18e0d07916044c7b6d3151984521192d486f1/src/denselinear.jl#L202-L257">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearCombinations.Linear1" href="#LinearCombinations.Linear1"><code>LinearCombinations.Linear1</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Linear1{T,R} &lt;: AbstractLinear{T,R}

Linear1{T,R}(itr)</code></pre><p>Construct a linear combination of type <code>Linear1</code> with term type <code>T</code> and coefficient type <code>R</code> out of the term-coefficient pairs provided by the iterator <code>itr</code>.</p><p>Linear combinations of this type can hold at most one non-zero term-coefficient pair at any time. There are often situations where this is sufficient, and in these cases <code>Linear1</code> is much more efficient than <code>Linear</code> or <code>DenseLinear</code>.</p><p>Other ways to use this constructor are discussed under <code>AbstractLinear</code>.</p><p>See also <a href="#LinearCombinations.AbstractLinear"><code>AbstractLinear</code></a>, <a href="#LinearCombinations.Linear"><code>Linear</code></a>, <a href="#LinearCombinations.DenseLinear"><code>DenseLinear</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = Linear1(&#39;x&#39; =&gt; 1)
Linear1{Char, Int64} with 1 term:
&#39;x&#39;

julia&gt; add!(a, &#39;x&#39;)
Linear1{Char, Int64} with 1 term:
2*&#39;x&#39;

julia&gt; addmul!(a, &#39;x&#39;, -2)
Linear1{Char, Int64} with 0 terms:
0

julia&gt; a + &#39;y&#39;   # works because a is zero
Linear1{Char, Int64} with 1 term:
&#39;y&#39;

julia&gt; a + &#39;y&#39; + &#39;z&#39;
ERROR: Linear1 cannot store linear combinations of two or more elements
[...]

julia&gt; a = Linear1(&#39;x&#39; =&gt; 1); b = Linear1(&#39;y&#39; =&gt; 2); a+b
Linear{Char, Int64} with 2 terms:
&#39;x&#39;+2*&#39;y&#39;

julia&gt; typeof(ans)
Linear{Char, Int64}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/LinearCombinations.jl/blob/b2b18e0d07916044c7b6d3151984521192d486f1/src/linear1.jl#L7-L53">source</a></section></article><h2 id="Basic-methods"><a class="docs-heading-anchor" href="#Basic-methods">Basic methods</a><a id="Basic-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearCombinations.termtype" href="#LinearCombinations.termtype"><code>LinearCombinations.termtype</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">termtype(::Type{L}) where L &lt;: AbstractLinear{T,R} = T
termtype(a::L) where L &lt;: AbstractLinear{T,R} = T</code></pre><p>Return the type of the terms (basis elements) in a linear combination.</p><p>See also <a href="#LinearCombinations.coefftype"><code>coefftype</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/LinearCombinations.jl/blob/b2b18e0d07916044c7b6d3151984521192d486f1/src/abstractlinear.jl#L218-L225">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearCombinations.coefftype" href="#LinearCombinations.coefftype"><code>LinearCombinations.coefftype</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">coefftype(::Type{L}) where L &lt;: AbstractLinear{T,R} = R
coefftype(a::L) where L &lt;: AbstractLinear{T,R} = R</code></pre><p>Return the type of the coefficients in a linear combination.</p><p>See also <a href="#LinearCombinations.termtype"><code>termtype</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/LinearCombinations.jl/blob/b2b18e0d07916044c7b6d3151984521192d486f1/src/abstractlinear.jl#L243-L250">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.in-Tuple{Any, AbstractLinear}" href="#Base.in-Tuple{Any, AbstractLinear}"><code>Base.in</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">x in a::AbstractLinear -&gt; Bool</code></pre><p>Return <code>true</code> if the term <code>x</code> appears in the linear combination <code>a</code> with a non-zero coefficient, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/LinearCombinations.jl/blob/b2b18e0d07916044c7b6d3151984521192d486f1/src/abstractlinear.jl#L307-L312">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.length-Tuple{AbstractLinear}" href="#Base.length-Tuple{AbstractLinear}"><code>Base.length</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">length(a::AbstractLinear) -&gt; Int</code></pre><p>Return the number of non-zero terms in <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/LinearCombinations.jl/blob/b2b18e0d07916044c7b6d3151984521192d486f1/src/abstractlinear.jl#L144-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.iterate-Tuple{AbstractLinear}" href="#Base.iterate-Tuple{AbstractLinear}"><code>Base.iterate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iterate(a::AbstractLinear [, state])</code></pre><p>Iterating over a linear combination yields all non-zero term-coefficient pairs.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = Linear(&#39;x&#39; =&gt; 1, &#39;y&#39; =&gt; 2, &#39;z&#39; =&gt; 0)
Linear{Char, Int64} with 2 terms:
&#39;x&#39;+2*&#39;y&#39;

julia&gt; collect(a)
2-element Vector{Pair{Char, Int64}}:
 &#39;x&#39; =&gt; 1
 &#39;y&#39; =&gt; 2

julia&gt; Linear(x =&gt; c^2 for (x, c) in a)
Linear{Char, Int64} with 2 terms:
&#39;x&#39;+4*&#39;y&#39;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/LinearCombinations.jl/blob/b2b18e0d07916044c7b6d3151984521192d486f1/src/abstractlinear.jl#L151-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearCombinations.coeffs" href="#LinearCombinations.coeffs"><code>LinearCombinations.coeffs</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">coeffs(a::AbstractLinear)</code></pre><p>Return an iterator over the non-zero coefficients appearing in <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/LinearCombinations.jl/blob/b2b18e0d07916044c7b6d3151984521192d486f1/src/abstractlinear.jl#L293-L297">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearCombinations.terms" href="#LinearCombinations.terms"><code>LinearCombinations.terms</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">terms(a::AbstractLinear)</code></pre><p>Return an iterator over the terms appearing in <code>a</code> (with a non-zero coefficient).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/LinearCombinations.jl/blob/b2b18e0d07916044c7b6d3151984521192d486f1/src/abstractlinear.jl#L300-L304">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.zero" href="#Base.zero"><code>Base.zero</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">zero(::Type{L}; kw...) where L &lt;: AbstractLinear -&gt; L
zero(a::L) where L &lt;: AbstractLinear -&gt; L</code></pre><p>Return a zero linear combination of type <code>L</code>. If <code>zero</code> is called with a type <code>L &lt;: AbstractLinear</code> as argument, then keyword arguments may be accepted or required.</p><p>See also <a href="#LinearCombinations.zero!"><code>zero!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/LinearCombinations.jl/blob/b2b18e0d07916044c7b6d3151984521192d486f1/src/abstractlinear.jl#L108-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearCombinations.zero!" href="#LinearCombinations.zero!"><code>LinearCombinations.zero!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">zero!(a::AbstractLinear) -&gt; a</code></pre><p>Set <code>a</code> equal to the zero linear combination and return <code>a</code>.</p><p>See also <a href="#Base.zero"><code>zero</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/LinearCombinations.jl/blob/b2b18e0d07916044c7b6d3151984521192d486f1/src/abstractlinear.jl#L284-L290">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.copy" href="#Base.copy"><code>Base.copy</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">copy(a::L) where L &lt;: AbstractLinear -&gt; L</code></pre><p>Return a copy of <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/LinearCombinations.jl/blob/b2b18e0d07916044c7b6d3151984521192d486f1/src/abstractlinear.jl#L651-L655">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.copyto!" href="#Base.copyto!"><code>Base.copyto!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">copyto!(a::AbstractLinear, b::AbstractLinear, c = 1) -&gt; a
copyto!(a::AbstractLinear, x, c = 1) -&gt; a</code></pre><p>Set <code>a</code> equal to the <code>c</code>-fold multiple of the linear combination <code>b</code> or of the term <code>x</code>. If the scalar <code>c</code> is omitted, it is taken to be <code>1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/LinearCombinations.jl/blob/b2b18e0d07916044c7b6d3151984521192d486f1/src/abstractlinear.jl#L639-L645">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.sizehint!" href="#Base.sizehint!"><code>Base.sizehint!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sizehint!(a::AbstractLinear, n::Integer) -&gt; a</code></pre><p>Try to make room for in total <code>n</code> non-zero term-coefficient pairs in the linear combination <code>a</code>.</p><p>This can speed up computations. At present, <code>sizehint!</code> has an effect for elements of type <code>Linear</code> (which internally use a dictionary) and is ignored for all other subtypes of <code>AbstractLinear</code>.</p><p>See also <a href="#LinearCombinations.Linear"><code>Linear</code></a>, <a href="../extensions/#LinearCombinations.has_sizehint"><code>LinearCombinations.has_sizehint</code></a>, <code>Base.sizehint!(d::AbstractDict)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/LinearCombinations.jl/blob/b2b18e0d07916044c7b6d3151984521192d486f1/src/abstractlinear.jl#L483-L492">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.convert" href="#Base.convert"><code>Base.convert</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert(::Type{L}, a::AbstractLinear; kw...) where L &lt;: AbstractLinear -&gt; L
convert(::Type{L}, x; kw...) where L &lt;: AbstractLinear -&gt; L</code></pre><p>Convert the linear combination <code>a</code> or the term <code>x</code> to a linear combination of type <code>L</code>. Keyword arguments are passed to the constructor for <code>L</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = Linear{AbstractChar,Int}(&#39;x&#39; =&gt; 2)
Linear{AbstractChar, Int64} with 1 term:
2*&#39;x&#39;

julia&gt; b = convert(Linear{Char,Float64}, a)
Linear{Char, Float64} with 1 term:
2.0*&#39;x&#39;

julia&gt; convert(Linear{Char,Int}, &#39;x&#39;) == Linear(&#39;x&#39; =&gt; 1)
true

julia&gt; convert(DenseLinear, a; basis = Basis(&#39;a&#39;:&#39;z&#39;))
DenseLinear{AbstractChar, Int64} with 1 term:
2*&#39;x&#39;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/LinearCombinations.jl/blob/b2b18e0d07916044c7b6d3151984521192d486f1/src/abstractlinear.jl#L447-L471">source</a></section></article><h3 id="Additional-functions-for-DenseLinear"><a class="docs-heading-anchor" href="#Additional-functions-for-DenseLinear">Additional functions for <code>DenseLinear</code></a><a id="Additional-functions-for-DenseLinear-1"></a><a class="docs-heading-anchor-permalink" href="#Additional-functions-for-DenseLinear" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearCombinations.basis" href="#LinearCombinations.basis"><code>LinearCombinations.basis</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">basis(a::DenseLinear) -&gt; Basis</code></pre><p>Return the basis specified when <code>a</code> was defined.</p><p>See also <a href="#LinearCombinations.coordinates"><code>coordinates</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/LinearCombinations.jl/blob/b2b18e0d07916044c7b6d3151984521192d486f1/src/denselinear.jl#L276-L282">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearCombinations.coordinates" href="#LinearCombinations.coordinates"><code>LinearCombinations.coordinates</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">coordinates(a::DenseLinear{T,R}) -&gt; AbstractArray{R}</code></pre><p>Return the coordinates of <code>a</code> with respect to the basis used for it. The coordinate array (usually a vector) has the same axes as the basis. Modifying this array will also modify <code>a</code>.</p><p>See also <a href="#LinearCombinations.basis"><code>basis</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; b = Basis(&#39;x&#39;:&#39;z&#39;)
Basis(&#39;x&#39;:1:&#39;z&#39;)

julia&gt; a = DenseLinear(&#39;x&#39; =&gt; 1, &#39;z&#39; =&gt; 2; basis = b)
DenseLinear{Char, Int64} with 2 terms:
&#39;x&#39;+2*&#39;z&#39;

julia&gt; v = coordinates(a)
3-element Vector{Int64}:
 1
 0
 2

julia&gt; a == Linear(x =&gt; c for (x, c) in zip(basis(a), v))
true

julia&gt; v[2] = -1; a
DenseLinear{Char, Int64} with 3 terms:
&#39;x&#39;-&#39;y&#39;+2*&#39;z&#39;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/LinearCombinations.jl/blob/b2b18e0d07916044c7b6d3151984521192d486f1/src/denselinear.jl#L285-L316">source</a></section></article><h2 id="Arithmetic"><a class="docs-heading-anchor" href="#Arithmetic">Arithmetic</a><a id="Arithmetic-1"></a><a class="docs-heading-anchor-permalink" href="#Arithmetic" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearCombinations.add!" href="#LinearCombinations.add!"><code>LinearCombinations.add!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add!(a::AbstractLinear, b::AbstractLinear) -&gt; a
add!(a::AbstractLinear, x) -&gt; a</code></pre><p>Add the linear combination <code>b</code> or the term <code>x</code> to <code>a</code>. This function modifies <code>a</code>.</p><p>See also <a href="#LinearCombinations.addmul!"><code>addmul!</code></a>, <a href="#LinearCombinations.sub!"><code>sub!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/LinearCombinations.jl/blob/b2b18e0d07916044c7b6d3151984521192d486f1/src/abstractlinear.jl#L619-L626">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearCombinations.sub!" href="#LinearCombinations.sub!"><code>LinearCombinations.sub!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sub!(a::AbstractLinear, b::AbstractLinear) -&gt; a
sub!(a::AbstractLinear, x) -&gt; a</code></pre><p>Subtract the linear combination <code>b</code> or the term <code>x</code> from <code>a</code>. This function modifies <code>a</code>.</p><p>See also <a href="#LinearCombinations.addmul!"><code>addmul!</code></a>, <a href="#LinearCombinations.add!"><code>add!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/LinearCombinations.jl/blob/b2b18e0d07916044c7b6d3151984521192d486f1/src/abstractlinear.jl#L629-L636">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearCombinations.mul!" href="#LinearCombinations.mul!"><code>LinearCombinations.mul!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mul!(a::AbstractLinear, c) -&gt; a</code></pre><p>Multiply <code>a</code> by the scalar <code>c</code>. This functions modifies <code>a</code>.</p><p>See also <a href="#LinearCombinations.addmul!"><code>addmul!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/LinearCombinations.jl/blob/b2b18e0d07916044c7b6d3151984521192d486f1/src/abstractlinear.jl#L315-L321">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearCombinations.addmul!" href="#LinearCombinations.addmul!"><code>LinearCombinations.addmul!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">addmul!(a::AbstractLinear, b::AbstractLinear, c) -&gt; a
addmul!(a::AbstractLinear, x, c) -&gt; a</code></pre><p>Add the <code>c</code>-fold multiple of the linear combination <code>b</code> or of the term <code>x</code> to <code>a</code>, where <code>c</code> is a scalar. This function modifies <code>a</code>.</p><p>See also <a href="#LinearCombinations.addmul"><code>addmul</code></a>, <a href="#LinearCombinations.add!"><code>add!</code></a>, <a href="#LinearCombinations.sub!"><code>sub!</code></a>, <a href="#LinearCombinations.mul!"><code>mul!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/LinearCombinations.jl/blob/b2b18e0d07916044c7b6d3151984521192d486f1/src/abstractlinear.jl#L571-L579">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearCombinations.addmul" href="#LinearCombinations.addmul"><code>LinearCombinations.addmul</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">addmul(a::AbstractLinear, b::AbstractLinear, c)
addmul(a::AbstractLinear, x, c)</code></pre><p>Add the <code>c</code>-fold multiple of the linear combination <code>b</code> or of the term <code>x</code> to <code>a</code>, where <code>c</code> is a scalar.</p><p>See also <a href="#LinearCombinations.addmul!"><code>addmul!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/LinearCombinations.jl/blob/b2b18e0d07916044c7b6d3151984521192d486f1/src/abstractlinear.jl#L608-L616">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearCombinations.deg-Tuple{AbstractLinear}" href="#LinearCombinations.deg-Tuple{AbstractLinear}"><code>LinearCombinations.deg</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">deg(a::AbstractLinear)</code></pre><p>Return <code>deg(x)</code> where <code>x</code> is the first term appearing in <code>a</code> (as determined by <code>first(a)</code>).</p><p>The linear combination <code>a</code> must not be zero. If <code>a</code> is homogeneous, then <code>deg(a)</code> is the common degree of all terms in it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/LinearCombinations.jl/blob/b2b18e0d07916044c7b6d3151984521192d486f1/src/abstractlinear.jl#L726-L733">source</a></section></article><h2 id="Calling-linear-combinations"><a class="docs-heading-anchor" href="#Calling-linear-combinations">Calling linear combinations</a><a id="Calling-linear-combinations-1"></a><a class="docs-heading-anchor-permalink" href="#Calling-linear-combinations" title="Permalink"></a></h2><p>Calling objects is extended linearly. Here is an example:</p><pre><code class="language-julia-repl hljs">julia&gt; struct P{T} y::T end

julia&gt; Base.hash(p::P, h::UInt) = hash(p.y, hash(P, h));  # `Linear` uses hashing

julia&gt; @linear p::P; (p::P)(x) = x * p.y

julia&gt; p, q = P(&#39;p&#39;), P(&#39;q&#39;)
(P{Char}(&#39;p&#39;), P{Char}(&#39;q&#39;))

julia&gt; p(&#39;x&#39;)
&quot;xp&quot;

julia&gt; a = Linear(&#39;x&#39; =&gt; 1, &#39;y&#39; =&gt; 2)
Linear{Char, Int64} with 2 terms:
&#39;x&#39;+2*&#39;y&#39;

julia&gt; p(a)
Linear{String, Int64} with 2 terms:
2*&quot;yp&quot;+&quot;xp&quot;

julia&gt; u = Linear(p =&gt; -1, q =&gt; 3)
Linear{P{Char}, Int64} with 2 terms:
-P{Char}(&#39;p&#39;)+3*P{Char}(&#39;q&#39;)

julia&gt; u(&#39;x&#39;)
Linear{String, Int64} with 2 terms:
3*&quot;xq&quot;-&quot;xp&quot;

julia&gt; u(a)
Linear{String, Int64} with 4 terms:
3*&quot;xq&quot;-2*&quot;yp&quot;+6*&quot;yq&quot;-&quot;xp&quot;</code></pre><h2 id="Broadcasting"><a class="docs-heading-anchor" href="#Broadcasting">Broadcasting</a><a id="Broadcasting-1"></a><a class="docs-heading-anchor-permalink" href="#Broadcasting" title="Permalink"></a></h2><p>Broadcasting is supported for <code>AbstractLinear</code> types. Broadcasted versions of <code>+</code>, <code>-</code>, <code>*</code>, <code>=</code> are converted to <a href="#LinearCombinations.addmul!"><code>addmul!</code></a>, <a href="#LinearCombinations.mul!"><code>mul!</code></a> and <a href="#Base.copyto!"><code>copyto!</code></a> as much as possible to avoid (or at least minimize) allocations. For example, for linear combinations <code>a</code>, <code>b</code>, <code>c</code> and <code>d</code>, the statement</p><pre><code class="language-julia hljs">   a .= b .+ 2 .* (c .- 3 .* d)</code></pre><p>is translated to</p><pre><code class="language-julia hljs">    copyto!(a, b)
    addmul!(a, c, 2)
    addmul!(a, d, 2*(-3))</code></pre><p>and the statement</p><pre><code class="language-julia hljs">    a .+= b .+ 2 .* (c .- 3 .* d)</code></pre><p>to</p><pre><code class="language-julia hljs">    addmul!(a, b)
    addmul!(a, c, 2)
    addmul!(a, d, 2*(-3))</code></pre><p>Broadcasted <code>.*</code> is always interpreted as scalar multiplication, with the scalar as the first argument. The only exception is a statement of the form <code>a .*= c</code> (that is, <code>a .= a .* c</code>) where the scalar is the second argument.</p><p>By default, only elements of types <code>AbstractLinear</code> and <code>Number</code> participate in broadcasting. To allow other scalar or term types, one has to use the macro <code>@linear_broadcastable</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; @linear_broadcastable Char

julia&gt; a, b = Linear(&#39;x&#39; =&gt; 1), Linear(&#39;y&#39; =&gt; 2)
(Linear{Char, Int64}(&#39;x&#39; =&gt; 1), Linear{Char, Int64}(&#39;y&#39; =&gt; 2))

julia&gt; a .+= b .+ 2 .* &#39;z&#39;
Linear{Char, Int64} with 3 terms:
&#39;x&#39;+2*&#39;y&#39;+2*&#39;z&#39;

julia&gt; a
Linear{Char, Int64} with 3 terms:
&#39;x&#39;+2*&#39;y&#39;+2*&#39;z&#39;</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearCombinations.@linear_broadcastable" href="#LinearCombinations.@linear_broadcastable"><code>LinearCombinations.@linear_broadcastable</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@linear_broadcastable T</code></pre><p>Add the type <code>T</code> to the types that participate in broadcasting for linear combinations. By default, only the types <code>AbstractLinear</code> and <code>Number</code> are available. (A few others happen to work as well, for example <code>AbstractChar</code>.)</p><p>See also <a href="../internals/#LinearCombinations.LinearStyle"><code>LinearCombinations.LinearStyle</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/LinearCombinations.jl/blob/b2b18e0d07916044c7b6d3151984521192d486f1/src/broadcast.jl#L22-L30">source</a></section></article><h2 id="AbstractLinear-interface"><a class="docs-heading-anchor" href="#AbstractLinear-interface"><code>AbstractLinear</code> interface</a><a id="AbstractLinear-interface-1"></a><a class="docs-heading-anchor-permalink" href="#AbstractLinear-interface" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearCombinations.getcoeff" href="#LinearCombinations.getcoeff"><code>LinearCombinations.getcoeff</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinearCombinations.getcoeff(a::AbstractLinear{T,R}, x) where {T,R} -&gt; R</code></pre><p>Return the coefficient of <code>x</code> in the linear combination <code>a</code>. This is <code>zero(R)</code> if <code>x</code> does not appear in <code>a</code>.</p><p>This function is part of the <code>AbstractLinear</code> interface. When it is called, the term <code>x</code> has already been transformed via <code>termcoeff</code>, and <code>linear_filter(x)</code> is <code>true</code>.</p><p>See also <a href="#LinearCombinations.setcoeff!"><code>LinearCombinations.setcoeff!</code></a>, <a href="../extensions/#LinearCombinations.linear_filter"><code>linear_filter</code></a>, <a href="../extensions/#LinearCombinations.termcoeff"><code>LinearCombinations.termcoeff</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/LinearCombinations.jl/blob/b2b18e0d07916044c7b6d3151984521192d486f1/src/abstractlinear.jl#L119-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearCombinations.setcoeff!" href="#LinearCombinations.setcoeff!"><code>LinearCombinations.setcoeff!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinearCombinations.setcoeff!(a::AbstractLinear{T,R}, c, x) where {T,R} -&gt; c</code></pre><p>Set the coefficient of <code>x</code> in the linear combination <code>a</code> equal to <code>c</code> and return <code>c</code>.</p><p>This function is part of the <code>AbstractLinear</code> interface. When it is called, both <code>x</code> and <code>c</code> have already been transformed via <code>termcoeff</code>, and <code>linear_filter(x)</code> is <code>true</code>.</p><p>See also <a href="#LinearCombinations.getcoeff"><code>LinearCombinations.getcoeff</code></a>, <a href="../extensions/#LinearCombinations.linear_filter"><code>linear_filter</code></a>, <a href="../extensions/#LinearCombinations.termcoeff"><code>LinearCombinations.termcoeff</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/LinearCombinations.jl/blob/b2b18e0d07916044c7b6d3151984521192d486f1/src/abstractlinear.jl#L132-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearCombinations.modifycoeff!" href="#LinearCombinations.modifycoeff!"><code>LinearCombinations.modifycoeff!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinearCombinations.modifycoeff!(op, a::AbstractLinear, x, c) -&gt; a</code></pre><p>Replace the coefficient of <code>x</code> in <code>a</code> by <code>op(getcoeff(a, x), c)</code> and return <code>a</code>. Here <code>op</code> is either <code>+</code> or <code>-</code>.</p><p>This function is called after <code>termcoeff</code> and <code>linear_filter</code>.</p><p>See also <a href="../extensions/#LinearCombinations.linear_filter"><code>linear_filter</code></a>, <a href="../extensions/#LinearCombinations.termcoeff"><code>LinearCombinations.termcoeff</code></a>, <a href="#LinearCombinations.modifylinear!"><code>LinearCombinations.modifylinear!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/LinearCombinations.jl/blob/b2b18e0d07916044c7b6d3151984521192d486f1/src/abstractlinear.jl#L538-L547">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearCombinations.modifylinear!" href="#LinearCombinations.modifylinear!"><code>LinearCombinations.modifylinear!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinearCombinations.modifylinear!(op, a::AbstractLinear, b::AbstractLinear, c = missing) -&gt; a</code></pre><p>If <code>op</code> is <code>+</code>, add <code>c*b</code> to <code>a</code>, or just <code>b</code> if <code>c</code> is missing. If <code>op</code> is <code>-</code>, subtract <code>b</code> or <code>c*b</code> from <code>a</code>. Store the new value in <code>a</code> and return it.</p><p>See also <a href="#LinearCombinations.modifycoeff!"><code>LinearCombinations.modifycoeff!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/LinearCombinations.jl/blob/b2b18e0d07916044c7b6d3151984521192d486f1/src/abstractlinear.jl#L553-L561">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Overview</a><a class="docs-footer-nextpage" href="../basis/">Bases »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.0 on <span class="colophon-date" title="Wednesday 14 May 2025 21:04">Wednesday 14 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
